<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>empix &mdash; empix  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/readthedocs_custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            empix
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../INSTALL.html">1. Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_autosummary/empix.html">2. Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">3. Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../todo.html">4. To-Do list</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">5. CHANGELOG</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">6. License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">empix</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">empix</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for empix</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;``empix`` is a Python library that contains tools for analyzing electron</span>
<span class="sd">microscopy data that are not available in `hyperspy</span>
<span class="sd">&lt;https://hyperspy.org/hyperspy-doc/current/index.html&gt;`_.</span>

<span class="sd">&quot;&quot;&quot;</span>



<span class="c1">#####################################</span>
<span class="c1">## Load libraries/packages/modules ##</span>
<span class="c1">#####################################</span>

<span class="c1"># For general array handling.</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># For interpolating data.</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span>

<span class="c1"># For validating and converting objects.</span>
<span class="kn">import</span> <span class="nn">czekitout.check</span>
<span class="kn">import</span> <span class="nn">czekitout.convert</span>

<span class="c1"># For defining classes that support enforced validation, updatability,</span>
<span class="c1"># pre-serialization, and de-serialization.</span>
<span class="kn">import</span> <span class="nn">fancytypes</span>

<span class="c1"># For creating hyperspy signals.</span>
<span class="kn">import</span> <span class="nn">hyperspy.signals</span>

<span class="c1"># For azimuthally integrating 2D hyperspy signals.</span>
<span class="kn">import</span> <span class="nn">pyFAI.detectors</span>
<span class="kn">import</span> <span class="nn">pyFAI.azimuthalIntegrator</span>

<span class="c1"># For downsampling hyperspy signals.</span>
<span class="kn">import</span> <span class="nn">skimage.measure</span>



<span class="c1"># Import child modules and packages of current package.</span>
<span class="kn">import</span> <span class="nn">empix.version</span>



<span class="c1">############################</span>
<span class="c1">## Authorship information ##</span>
<span class="c1">############################</span>

<span class="n">__author__</span>       <span class="o">=</span> <span class="s2">&quot;Matthew Fitzpatrick&quot;</span>
<span class="n">__copyright__</span>    <span class="o">=</span> <span class="s2">&quot;Copyright 2023&quot;</span>
<span class="n">__credits__</span>      <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Matthew Fitzpatrick&quot;</span><span class="p">]</span>
<span class="n">__version__</span>      <span class="o">=</span> <span class="n">empix</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">version</span>
<span class="n">__full_version__</span> <span class="o">=</span> <span class="n">empix</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">full_version</span>
<span class="n">__maintainer__</span>   <span class="o">=</span> <span class="s2">&quot;Matthew Fitzpatrick&quot;</span>
<span class="n">__email__</span>        <span class="o">=</span> <span class="s2">&quot;mrfitzpa@uvic.ca&quot;</span>
<span class="n">__status__</span>       <span class="o">=</span> <span class="s2">&quot;Development&quot;</span>



<span class="c1">###################################</span>
<span class="c1">## Useful background information ##</span>
<span class="c1">###################################</span>

<span class="c1"># See e.g. ``https://docs.python.org/3/reference/import.html#regular-packages``</span>
<span class="c1"># for a brief discussion of ``__init__.py`` files.</span>



<span class="c1">##################################</span>
<span class="c1">## Define classes and functions ##</span>
<span class="c1">##################################</span>

<span class="c1"># List of public objects in package.</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;abs_sq&quot;</span><span class="p">,</span>
           <span class="s2">&quot;OptionalAzimuthalAveragingParams&quot;</span><span class="p">,</span>
           <span class="s2">&quot;azimuthally_average&quot;</span><span class="p">,</span>
           <span class="s2">&quot;OptionalAzimuthalIntegrationParams&quot;</span><span class="p">,</span>
           <span class="s2">&quot;azimuthally_integrate&quot;</span><span class="p">,</span>
           <span class="s2">&quot;OptionalAnnularAveragingParams&quot;</span><span class="p">,</span>
           <span class="s2">&quot;annularly_average&quot;</span><span class="p">,</span>
           <span class="s2">&quot;OptionalAnnularIntegrationParams&quot;</span><span class="p">,</span>
           <span class="s2">&quot;annularly_integrate&quot;</span><span class="p">,</span>
           <span class="s2">&quot;OptionalCumulative1dIntegrationParams&quot;</span><span class="p">,</span>
           <span class="s2">&quot;cumulatively_integrate_1d&quot;</span><span class="p">,</span>
           <span class="s2">&quot;OptionalCroppingParams&quot;</span><span class="p">,</span>
           <span class="s2">&quot;crop&quot;</span><span class="p">,</span>
           <span class="s2">&quot;OptionalDownsamplingParams&quot;</span><span class="p">,</span>
           <span class="s2">&quot;downsample&quot;</span><span class="p">,</span>
           <span class="s2">&quot;OptionalResamplingParams&quot;</span><span class="p">,</span>
           <span class="s2">&quot;resample&quot;</span><span class="p">]</span>



<div class="viewcode-block" id="abs_sq"><a class="viewcode-back" href="../_autosummary/empix.abs_sq.html#empix.abs_sq">[docs]</a><span class="k">def</span> <span class="nf">abs_sq</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The modulus squared of a given input ``hyperspy`` signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_signal : :class:`hyperspy._signals.signal1d.Signal1D` | :class:`hyperspy._signals.complex_signal1d.ComplexSignal1D` | :class:`hyperspy._signals.signal2d.Signal2D` | :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D`</span>
<span class="sd">        The input ``hyperspy`` signal.</span>
<span class="sd">    title : `str` | `None`, optional</span>
<span class="sd">        If ``title`` is set to ``None``, then the title of the output signal</span>
<span class="sd">        ``output_signal`` is set to ``&quot;Modulus Squared of &quot; +</span>
<span class="sd">        input_signal.metadata.General.title``, where ``input_signal`` is the </span>
<span class="sd">        input ``hyperspy`` signal.  Otherwise, if ``title`` is a `str`, then the</span>
<span class="sd">        ``output_signal.metadata.General.title`` is set to the value of </span>
<span class="sd">        ``title``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output_signal : :class:`hyperspy._signals.signal1d.Signal1D` | :class:`hyperspy._signals.signal2d.Signal2D`</span>
<span class="sd">        The output ``hyperspy`` signal that stores the modulus squared of the</span>
<span class="sd">        input signal ``input_signal``. Note that except for the title, the</span>
<span class="sd">        metadata of the output signal is determined from the metadata of the</span>
<span class="sd">        input signal.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_input_signal</span><span class="p">(</span><span class="n">input_signal</span><span class="p">)</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">_check_and_convert_title_v2</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">)</span>

    <span class="n">ComplexSignal</span> <span class="o">=</span> <span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">ComplexSignal</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">ComplexSignal</span><span class="p">):</span>
        <span class="n">output_signal</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">amplitude</span>
        <span class="n">output_signal</span> <span class="o">*=</span> <span class="n">output_signal</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output_signal</span> <span class="o">=</span> <span class="n">input_signal</span> <span class="o">*</span> <span class="n">input_signal</span>

    <span class="n">output_signal</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">General</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">title</span>

    <span class="k">return</span> <span class="n">output_signal</span></div>



<span class="k">def</span> <span class="nf">_check_input_signal</span><span class="p">(</span><span class="n">input_signal</span><span class="p">):</span>
    <span class="n">accepted_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal1D</span><span class="p">,</span>
                      <span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">,</span>
                      <span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">ComplexSignal1D</span><span class="p">,</span>
                      <span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">ComplexSignal2D</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;obj&quot;</span><span class="p">:</span> <span class="n">input_signal</span><span class="p">,</span>
              <span class="s2">&quot;obj_name&quot;</span><span class="p">:</span> <span class="s2">&quot;input_signal&quot;</span><span class="p">,</span>
              <span class="s2">&quot;accepted_types&quot;</span><span class="p">:</span> <span class="n">accepted_types</span><span class="p">}</span>
    <span class="n">czekitout</span><span class="o">.</span><span class="n">check</span><span class="o">.</span><span class="n">if_instance_of_any_accepted_types</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">input_signal</span>



<span class="k">def</span> <span class="nf">_check_and_convert_title_v1</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">):</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">ctor_params</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">czekitout</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_str_from_str_like</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="s2">&quot;title&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_check_and_convert_title_v1_err_msg_1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">title</span>



<span class="k">def</span> <span class="nf">_check_and_convert_title_v2</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">):</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">_check_and_convert_title_v1</span><span class="p">({</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">title</span><span class="p">})</span>
    <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">_default_title</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="s2">&quot;Modulus Squared of &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">title</span>



<span class="k">def</span> <span class="nf">_default_title</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">auto_prefix</span><span class="p">,</span> <span class="n">auto_suffix</span><span class="p">):</span>
    <span class="n">input_signal_title</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">General</span><span class="o">.</span><span class="n">title</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">auto_prefix</span> <span class="o">+</span> <span class="n">input_signal_title</span> <span class="o">+</span> <span class="n">auto_suffix</span>

    <span class="k">return</span> <span class="n">title</span>



<span class="k">def</span> <span class="nf">_check_and_convert_center_v1</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">):</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">ctor_params</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">czekitout</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_pair_of_floats</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="s2">&quot;center&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_check_and_convert_center_v1_err_msg_1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">center</span>



<span class="k">def</span> <span class="nf">_check_and_convert_radial_range_v1</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">):</span>
    <span class="n">radial_range</span> <span class="o">=</span> <span class="n">ctor_params</span><span class="p">[</span><span class="s2">&quot;radial_range&quot;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">radial_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">radial_range</span> <span class="o">=</span> <span class="n">czekitout</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_pair_of_floats</span><span class="p">(</span><span class="n">radial_range</span><span class="p">,</span>
                                                               <span class="s2">&quot;radial_range&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_check_and_convert_radial_range_v1_err_msg_1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">radial_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">radial_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_check_and_convert_radial_range_v1_err_msg_1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">radial_range</span>



<span class="k">def</span> <span class="nf">_check_and_convert_num_bins_v1</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">):</span>
    <span class="n">num_bins</span> <span class="o">=</span> <span class="n">ctor_params</span><span class="p">[</span><span class="s2">&quot;num_bins&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">num_bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">num_bins</span> <span class="o">=</span> <span class="n">czekitout</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_positive_int</span><span class="p">(</span><span class="n">num_bins</span><span class="p">,</span> <span class="s2">&quot;num_bins&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_check_and_convert_num_bins_v1_err_msg_1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">num_bins</span>



<span class="k">def</span> <span class="nf">_pre_serialize_center</span><span class="p">(</span><span class="n">center</span><span class="p">):</span>
    <span class="n">serializable_rep</span> <span class="o">=</span> <span class="n">center</span>
    
    <span class="k">return</span> <span class="n">serializable_rep</span>



<span class="k">def</span> <span class="nf">_pre_serialize_radial_range</span><span class="p">(</span><span class="n">radial_range</span><span class="p">):</span>
    <span class="n">serializable_rep</span> <span class="o">=</span> <span class="n">radial_range</span>
    
    <span class="k">return</span> <span class="n">serializable_rep</span>



<span class="k">def</span> <span class="nf">_pre_serialize_num_bins</span><span class="p">(</span><span class="n">num_bins</span><span class="p">):</span>
    <span class="n">serializable_rep</span> <span class="o">=</span> <span class="n">num_bins</span>
    
    <span class="k">return</span> <span class="n">serializable_rep</span>



<span class="k">def</span> <span class="nf">_pre_serialize_title</span><span class="p">(</span><span class="n">title</span><span class="p">):</span>
    <span class="n">serializable_rep</span> <span class="o">=</span> <span class="n">title</span>
    
    <span class="k">return</span> <span class="n">serializable_rep</span>



<span class="k">def</span> <span class="nf">_de_pre_serialize_center</span><span class="p">(</span><span class="n">serializable_rep</span><span class="p">):</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">serializable_rep</span>

    <span class="k">return</span> <span class="n">center</span>



<span class="k">def</span> <span class="nf">_de_pre_serialize_radial_range</span><span class="p">(</span><span class="n">serializable_rep</span><span class="p">):</span>
    <span class="n">radial_range</span> <span class="o">=</span> <span class="n">serializable_rep</span>

    <span class="k">return</span> <span class="n">radial_range</span>



<span class="k">def</span> <span class="nf">_de_pre_serialize_num_bins</span><span class="p">(</span><span class="n">serializable_rep</span><span class="p">):</span>
    <span class="n">num_bins</span> <span class="o">=</span> <span class="n">serializable_rep</span>

    <span class="k">return</span> <span class="n">num_bins</span>



<span class="k">def</span> <span class="nf">_de_pre_serialize_title</span><span class="p">(</span><span class="n">serializable_rep</span><span class="p">):</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">serializable_rep</span>

    <span class="k">return</span> <span class="n">title</span>



<div class="viewcode-block" id="OptionalAzimuthalAveragingParams"><a class="viewcode-back" href="../_autosummary/empix.OptionalAzimuthalAveragingParams.html#empix.OptionalAzimuthalAveragingParams">[docs]</a><span class="k">class</span> <span class="nc">OptionalAzimuthalAveragingParams</span><span class="p">(</span>
        <span class="n">fancytypes</span><span class="o">.</span><span class="n">PreSerializableAndUpdatable</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The set of optional parameters for the function</span>
<span class="sd">    :func:`empix.azimuthally_average`.</span>

<span class="sd">    The Python function :func:`empix.azimuthally_integrate` averages</span>
<span class="sd">    azimuthally a given input 2D ``hyperspy`` signal. The Python function</span>
<span class="sd">    assumes that the input 2D ``hyperspy`` signal samples from a mathematical</span>
<span class="sd">    function :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` which is piecewise</span>
<span class="sd">    continuous in :math:`u_{x}` and :math:`u_{y}`, where :math:`u_{x}` and</span>
<span class="sd">    :math:`u_{y}` are the horizontal and vertical coordinates in the signal</span>
<span class="sd">    space of the input signal, and :math:`\mathbf{m}` is a vector of integers</span>
<span class="sd">    representing the navigation indices of the input signal. The Python function</span>
<span class="sd">    approximates the azimuthal average of</span>
<span class="sd">    :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` given the input signal. We</span>
<span class="sd">    define the azimuthal average of</span>
<span class="sd">    :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` as</span>

<span class="sd">    .. math ::</span>
<span class="sd">	&amp;\overline{S}_{\mathbf{m}}\left(\left.R_{xy}=r_{xy}\right|</span>
<span class="sd">        0\le U_{\phi}&lt;2\pi;c_{x},c_{y}\right)\\&amp;\quad=\frac{1}{2\pi r_{xy}}</span>
<span class="sd">        \int_{0}^{2\pi}du_{\phi}\,u_{xy}</span>
<span class="sd">        F_{\mathbf{m}}\left(c_{x}+r_{xy}\cos\left(u_{\phi}\right),</span>
<span class="sd">        c_{y}+r_{xy}\sin\left(u_{\phi}\right)\right),</span>
<span class="sd">        :label: azimuthal_average__1</span>

<span class="sd">    where :math:`\left(c_{x},c_{y}\right)` is the reference point from which the</span>
<span class="sd">    radial distance :math:`r_{xy}` is defined for the azimuthal averaging.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    center : `array_like` (`float`, shape=(2,)) | `None`, optional</span>
<span class="sd">        If ``center`` is set to ``None``, then the reference point</span>
<span class="sd">        :math:`\left(c_{x},c_{y}\right)`, from which the radial distance is</span>
<span class="sd">        defined for the azimuthal averaging, is set to the signal space</span>
<span class="sd">        coordinates corresponding to the center signal space pixel.  Otherwise,</span>
<span class="sd">        if ``center`` is set to a pair of floating-point numbers, then</span>
<span class="sd">        ``center[0]`` and ``center[1]`` specify :math:`c_{x}` and :math:`c_{y}`</span>
<span class="sd">        respectively, in the same units of the corresponding signal space axes</span>
<span class="sd">        of the input signal.</span>
<span class="sd">    radial_range : `array_like` (`float`, shape=(2,)) | `None`, optional</span>
<span class="sd">        If ``radial_range`` is set to ``None``, then the radial range, over</span>
<span class="sd">        which the azimuthal averaging is performed, is from zero to the largest</span>
<span class="sd">        radial distance within the signal space boundaries of the input signal</span>
<span class="sd">        for all azimuthal angles. Otherwise, if ``radial_range`` is set to a</span>
<span class="sd">        pair of floating-point numbers, then ``radial_range[0]`` and</span>
<span class="sd">        ``radial_range[1]`` specify the minimum and maximum radial distances of</span>
<span class="sd">        the radial range respectively, in the same units of the horizontal and</span>
<span class="sd">        vertical axes respectively of the signal space of the input signal. Note</span>
<span class="sd">        that in this case ``radial_range`` must satisfy</span>
<span class="sd">        ``0&lt;=radial_range[0]&lt;=radial_range[1]``. Moreover, the function</span>
<span class="sd">        represented by the input signal is assumed to be equal to zero</span>
<span class="sd">        everywhere outside of the signal space boundaries of said input signal.</span>
<span class="sd">    num_bins : `int` | `None`, optional</span>
<span class="sd">        ``num_bins`` must either be a positive integer or of the `NoneType`: if</span>
<span class="sd">        the former, then the dimension of the signal space of the output signal</span>
<span class="sd">        ``output_signal`` is set to ``num_bins``; if the latter, then the</span>
<span class="sd">        dimension of the signal space of ``output_signal`` is set to</span>
<span class="sd">        ``min(input_signal.data.shape[-2:])``, where ``input_signal`` is the</span>
<span class="sd">        input ``hyperspy`` signal.</span>
<span class="sd">    title : `str` | `None`, optional</span>
<span class="sd">        If ``title`` is set to ``None``, then the title of the output signal</span>
<span class="sd">        ``output_signal`` is set to ``&quot;Azimuthally Averaged &quot; +</span>
<span class="sd">        input_signal.metadata.General.title``, where ``input_signal`` is the </span>
<span class="sd">        input ``hyperspy`` signal.  Otherwise, if ``title`` is a `str`, then the</span>
<span class="sd">        ``output_signal.metadata.General.title`` is set to the value of </span>
<span class="sd">        ``title``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    core_attrs : `dict`, read-only</span>
<span class="sd">        A `dict` representation of the core attributes: each `dict` key is a</span>
<span class="sd">        `str` representing the name of a core attribute, and the corresponding</span>
<span class="sd">        `dict` value is the object to which said core attribute is set. The core</span>
<span class="sd">        attributes are the same as the construction parameters, except that </span>
<span class="sd">        their values might have been updated since construction.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_validation_and_conversion_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_center_v1</span><span class="p">,</span>
         <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_radial_range_v1</span><span class="p">,</span>
         <span class="s2">&quot;num_bins&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_num_bins_v1</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_title_v1</span><span class="p">}</span>

    <span class="n">_pre_serialization_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_center</span><span class="p">,</span>
         <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_radial_range</span><span class="p">,</span>
         <span class="s2">&quot;num_bins&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_num_bins</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_title</span><span class="p">}</span>

    <span class="n">_de_pre_serialization_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_center</span><span class="p">,</span>
         <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_radial_range</span><span class="p">,</span>
         <span class="s2">&quot;num_bins&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_num_bins</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_title</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">radial_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">num_bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">ctor_params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">center</span><span class="p">,</span>
                       <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">radial_range</span><span class="p">,</span>
                       <span class="s2">&quot;num_bins&quot;</span><span class="p">:</span> <span class="n">num_bins</span><span class="p">,</span>
                       <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">title</span><span class="p">}</span>
        <span class="n">fancytypes</span><span class="o">.</span><span class="n">PreSerializableAndUpdatable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctor_params</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="azimuthally_average"><a class="viewcode-back" href="../_autosummary/empix.azimuthally_average.html#empix.azimuthally_average">[docs]</a><span class="k">def</span> <span class="nf">azimuthally_average</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">optional_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Average azimuthally a given input 2D ``hyperspy`` signal.</span>

<span class="sd">    This current Python function assumes that the input 2D ``hyperspy`` signal</span>
<span class="sd">    samples from a mathematical function</span>
<span class="sd">    :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` which is piecewise continuous</span>
<span class="sd">    in :math:`u_{x}` and :math:`u_{y}`, where :math:`u_{x}` and :math:`u_{y}`</span>
<span class="sd">    are the horizontal and vertical coordinates in the signal space of the input</span>
<span class="sd">    signal, and :math:`\mathbf{m}` is a vector of integers representing the</span>
<span class="sd">    navigation indices of the input signal. The Python function approximates the</span>
<span class="sd">    azimuthal average of :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` given</span>
<span class="sd">    the input signal. We define the azimuthal average of</span>
<span class="sd">    :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` as</span>

<span class="sd">    .. math ::</span>
<span class="sd">	&amp;\overline{S}_{\mathbf{m}}\left(\left.R_{xy}=r_{xy}\right|</span>
<span class="sd">        0\le U_{\phi}&lt;2\pi;c_{x},c_{y}\right)\\&amp;\quad=\frac{1}{2\pi r_{xy}}</span>
<span class="sd">        \int_{0}^{2\pi}du_{\phi}\,u_{xy}</span>
<span class="sd">        F_{\mathbf{m}}\left(c_{x}+r_{xy}\cos\left(u_{\phi}\right),</span>
<span class="sd">        c_{y}+r_{xy}\sin\left(u_{\phi}\right)\right),</span>
<span class="sd">        :label: azimuthal_average__2</span>

<span class="sd">    where :math:`\left(c_{x},c_{y}\right)` is the reference point from which the</span>
<span class="sd">    radial distance :math:`r_{xy}` is defined for the azimuthal averaging.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_signal : :class:`hyperspy._signals.signal2d.Signal2D` | :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D`</span>
<span class="sd">        The input ``hyperspy`` signal.</span>
<span class="sd">    optional_params : :class:`empix.OptionalAzimuthalAveragingParams` | `None`, optional</span>
<span class="sd">        The set of optional parameters. See the documentation for the class</span>
<span class="sd">        :class:`empix.OptionalAzimuthalAveragingParams` for details. If</span>
<span class="sd">        ``optional_params`` is set to ``None``, rather than an instance of</span>
<span class="sd">        :class:`empix.OptionalAzimuthalAveragingParams`, then the default</span>
<span class="sd">        values of the optional parameters are chosen.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output_signal : :class:`hyperspy._signals.signal1d.Signal1D` | :class:`hyperspy._signals.complex_signal1d.ComplexSignal1D`</span>
<span class="sd">        The output ``hyperspy`` signal that samples the azimuthal average of the</span>
<span class="sd">        input signal ``input_signal``. Note that except for the title, the</span>
<span class="sd">        metadata of the output signal is determined from the metadata of the</span>
<span class="sd">        input signal.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_2D_input_signal</span><span class="p">(</span><span class="n">input_signal</span><span class="p">)</span>
    <span class="n">center</span><span class="p">,</span> <span class="n">radial_range</span><span class="p">,</span> <span class="n">num_bins</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> \
        <span class="n">_check_and_convert_optional_params_v1</span><span class="p">(</span><span class="n">optional_params</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">_default_title</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="s2">&quot;Azimuthally Averaged &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    
    <span class="n">azimuthal_integrator</span> <span class="o">=</span> <span class="n">_construct_azimuthal_integrator</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">center</span><span class="p">)</span>

    <span class="n">bin_coords</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> \
        <span class="n">_apply_azimuthal_integrator_to_input_signal</span><span class="p">(</span><span class="n">azimuthal_integrator</span><span class="p">,</span>
                                                    <span class="n">input_signal</span><span class="p">,</span>
                                                    <span class="n">num_bins</span><span class="p">,</span>
                                                    <span class="n">radial_range</span><span class="p">)</span>
    
    <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;General&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">title</span><span class="p">},</span> <span class="s2">&quot;Signal&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">()}</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">output_data</span><span class="p">):</span>
        <span class="n">output_signal</span> <span class="o">=</span> <span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal1D</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">output_data</span><span class="p">,</span>
                                                  <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output_signal</span> <span class="o">=</span> <span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">ComplexSignal1D</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">output_data</span><span class="p">,</span>
                                                         <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>
    <span class="n">_update_output_signal_axes_v1</span><span class="p">(</span><span class="n">output_signal</span><span class="p">,</span> <span class="n">bin_coords</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output_signal</span></div>



<span class="k">def</span> <span class="nf">_check_2D_input_signal</span><span class="p">(</span><span class="n">input_signal</span><span class="p">):</span>
    <span class="n">accepted_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">,</span>
                      <span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">ComplexSignal2D</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;obj&quot;</span><span class="p">:</span> <span class="n">input_signal</span><span class="p">,</span>
              <span class="s2">&quot;obj_name&quot;</span><span class="p">:</span> <span class="s2">&quot;input_signal&quot;</span><span class="p">,</span>
              <span class="s2">&quot;accepted_types&quot;</span><span class="p">:</span> <span class="n">accepted_types</span><span class="p">}</span>
    <span class="n">czekitout</span><span class="o">.</span><span class="n">check</span><span class="o">.</span><span class="n">if_instance_of_any_accepted_types</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">input_signal</span>



<span class="k">def</span> <span class="nf">_check_and_convert_optional_params_v1</span><span class="p">(</span><span class="n">optional_params</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">optional_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">optional_params</span> <span class="o">=</span> <span class="n">OptionalAzimuthalAveragingParams</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optional_params</span><span class="p">,</span> <span class="n">OptionalAzimuthalAveragingParams</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_check_and_convert_optional_params_v1_err_msg_1</span><span class="p">)</span>

    <span class="n">center</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">_check_and_convert_center_v2</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">)</span>

    <span class="n">radial_range</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;radial_range&quot;</span><span class="p">]</span>
    <span class="n">radial_range</span> <span class="o">=</span> <span class="n">_check_and_convert_radial_range_v2</span><span class="p">(</span><span class="n">radial_range</span><span class="p">,</span>
                                                      <span class="n">input_signal</span><span class="p">,</span>
                                                      <span class="n">center</span><span class="p">)</span>

    <span class="n">num_bins</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;num_bins&quot;</span><span class="p">]</span>
    <span class="n">num_bins</span> <span class="o">=</span> <span class="n">_check_and_convert_num_bins_v2</span><span class="p">(</span><span class="n">num_bins</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">)</span>

    <span class="n">title</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">center</span><span class="p">,</span> <span class="n">radial_range</span><span class="p">,</span> <span class="n">num_bins</span><span class="p">,</span> <span class="n">title</span>



<span class="k">def</span> <span class="nf">_check_and_convert_center_v2</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">signal</span><span class="p">):</span>
    <span class="n">h_range</span><span class="p">,</span> <span class="n">v_range</span> <span class="o">=</span> <span class="n">_h_and_v_ranges</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">h_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">h_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">v_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">v_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_check_and_convert_center_v2_err_msg_2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">center</span> <span class="o">=</span> <span class="p">((</span><span class="n">h_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">h_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">v_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">v_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">center</span>


<span class="k">def</span> <span class="nf">_h_and_v_ranges</span><span class="p">(</span><span class="n">signal</span><span class="p">):</span>
    <span class="n">h_scale</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span>
    <span class="n">v_scale</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span>

    <span class="n">n_v</span><span class="p">,</span> <span class="n">n_h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>

    <span class="n">h_offset</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span>
    <span class="n">v_offset</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span>

    <span class="n">h_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">h_offset</span><span class="p">,</span> <span class="n">h_offset</span> <span class="o">+</span> <span class="n">n_h</span><span class="o">*</span><span class="n">h_scale</span><span class="p">)</span>
    <span class="n">h_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">h_offset</span><span class="p">,</span> <span class="n">h_offset</span> <span class="o">+</span> <span class="n">n_h</span><span class="o">*</span><span class="n">h_scale</span><span class="p">)</span>
    <span class="n">h_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">h_min</span><span class="p">,</span> <span class="n">h_max</span><span class="p">)</span>

    <span class="n">v_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">v_offset</span><span class="p">,</span> <span class="n">v_offset</span> <span class="o">+</span> <span class="n">n_v</span><span class="o">*</span><span class="n">v_scale</span><span class="p">)</span>
    <span class="n">v_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">v_offset</span><span class="p">,</span> <span class="n">v_offset</span> <span class="o">+</span> <span class="n">n_v</span><span class="o">*</span><span class="n">v_scale</span><span class="p">)</span>
    <span class="n">v_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_min</span><span class="p">,</span> <span class="n">v_max</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">h_range</span><span class="p">,</span> <span class="n">v_range</span>



<span class="k">def</span> <span class="nf">_check_and_convert_radial_range_v2</span><span class="p">(</span><span class="n">radial_range</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">center</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">radial_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">h_range</span><span class="p">,</span> <span class="n">v_range</span> <span class="o">=</span> <span class="n">_h_and_v_ranges</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
        <span class="n">temp_1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">h_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">h_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">temp_2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">radial_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">temp_1</span><span class="p">,</span> <span class="n">temp_2</span><span class="p">))</span>

    <span class="c1"># Need to multiply range by 1000 because of the units used in pyFAI&#39;s</span>
    <span class="c1"># azimuthal integrator.</span>
    <span class="n">radial_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">radial_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">1000</span><span class="p">,</span> <span class="n">radial_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">radial_range</span>



<span class="k">def</span> <span class="nf">_check_and_convert_num_bins_v2</span><span class="p">(</span><span class="n">num_bins</span><span class="p">,</span> <span class="n">signal</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">num_bins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">_is_1d_signal</span><span class="p">(</span><span class="n">signal</span><span class="p">):</span>
            <span class="n">num_bins</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_bins</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">num_bins</span>



<span class="k">def</span> <span class="nf">_is_1d_signal</span><span class="p">(</span><span class="n">signal</span><span class="p">):</span>
    <span class="n">signal_1d_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal1D</span><span class="p">,</span>
                       <span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">ComplexSignal1D</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">signal_1d_types</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>



<span class="k">def</span> <span class="nf">_construct_azimuthal_integrator</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">center</span><span class="p">):</span>
    <span class="n">detector</span> <span class="o">=</span> <span class="n">_construct_pyfai_detector</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

    <span class="n">h_scale</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span>
    <span class="n">v_scale</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span>

    <span class="c1"># ``pone_1`` and ``poni_2`` are the vertical and horizontal displacements</span>
    <span class="c1"># of the reference point, from which to perform the azimuthal integration,</span>
    <span class="c1"># from the top left corner of the input signal.</span>
    <span class="n">h_range</span><span class="p">,</span> <span class="n">v_range</span> <span class="o">=</span> <span class="n">_h_and_v_ranges</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">poni_1</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">v_scale</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">v_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">poni_2</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">h_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">h_scale</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">h_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># We require ``L &gt;&gt; max(v_pixel_size, h_pixel_size)``.</span>
    <span class="n">h_pixel_size</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">h_scale</span><span class="p">)</span>
    <span class="n">v_pixel_size</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v_scale</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mi">10000</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">v_pixel_size</span><span class="p">,</span> <span class="n">h_pixel_size</span><span class="p">)</span>

    <span class="n">AzimuthalIntegrator</span> <span class="o">=</span> <span class="n">pyFAI</span><span class="o">.</span><span class="n">azimuthalIntegrator</span><span class="o">.</span><span class="n">AzimuthalIntegrator</span>
    <span class="n">azimuthal_integrator</span> <span class="o">=</span> <span class="n">AzimuthalIntegrator</span><span class="p">(</span><span class="n">dist</span><span class="o">=</span><span class="n">L</span><span class="p">,</span>
                                               <span class="n">poni1</span><span class="o">=</span><span class="n">poni_1</span><span class="p">,</span> 
                                               <span class="n">poni2</span><span class="o">=</span><span class="n">poni_2</span><span class="p">,</span> 
                                               <span class="n">detector</span><span class="o">=</span><span class="n">detector</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">azimuthal_integrator</span>
    


<span class="k">def</span> <span class="nf">_construct_pyfai_detector</span><span class="p">(</span><span class="n">signal</span><span class="p">):</span>
    <span class="n">h_pixel_size</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
    <span class="n">v_pixel_size</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
    <span class="n">detector</span> <span class="o">=</span> <span class="n">pyFAI</span><span class="o">.</span><span class="n">detectors</span><span class="o">.</span><span class="n">Detector</span><span class="p">(</span><span class="n">pixel1</span><span class="o">=</span><span class="n">v_pixel_size</span><span class="p">,</span>
                                        <span class="n">pixel2</span><span class="o">=</span><span class="n">h_pixel_size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">detector</span>



<span class="k">def</span> <span class="nf">_apply_azimuthal_integrator_to_input_signal</span><span class="p">(</span><span class="n">azimuthal_integrator</span><span class="p">,</span>
                                                <span class="n">input_signal</span><span class="p">,</span>
                                                <span class="n">num_bins</span><span class="p">,</span>
                                                <span class="n">radial_range</span><span class="p">):</span>
    <span class="n">navigation_dims</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">output_data_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">navigation_dims</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">num_bins</span><span class="p">]</span>
    <span class="n">output_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">output_data_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">num_patterns</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">navigation_dims</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">pattern_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_patterns</span><span class="p">):</span>
        <span class="n">navigation_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">pattern_idx</span><span class="p">,</span> <span class="n">navigation_dims</span><span class="p">)</span>
        <span class="n">input_datasubset</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">navigation_indices</span><span class="p">]</span>
            
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;azimuthal_integrator&quot;</span><span class="p">:</span> <span class="n">azimuthal_integrator</span><span class="p">,</span>
                  <span class="s2">&quot;input_datasubset&quot;</span><span class="p">:</span> <span class="n">input_datasubset</span><span class="p">,</span>
                  <span class="s2">&quot;num_bins&quot;</span><span class="p">:</span> <span class="n">num_bins</span><span class="p">,</span>
                  <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">radial_range</span><span class="p">}</span>
        <span class="n">bin_coords</span><span class="p">,</span> <span class="n">output_datasubset</span> <span class="o">=</span> \
            <span class="n">_apply_azimuthal_integrator_to_input_datasubset</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">output_data</span><span class="p">[</span><span class="n">navigation_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_datasubset</span>
    
    <span class="n">bin_coords</span> <span class="o">/=</span> <span class="mi">1000</span>  <span class="c1"># Because of the artificial &quot;r_mm&quot; units.</span>

    <span class="k">return</span> <span class="n">bin_coords</span><span class="p">,</span> <span class="n">output_data</span>



<span class="k">def</span> <span class="nf">_apply_azimuthal_integrator_to_input_datasubset</span><span class="p">(</span><span class="n">azimuthal_integrator</span><span class="p">,</span>
                                                    <span class="n">input_datasubset</span><span class="p">,</span>
                                                    <span class="n">num_bins</span><span class="p">,</span>
                                                    <span class="n">radial_range</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">):</span>
        <span class="n">bin_coords</span><span class="p">,</span> <span class="n">output_datasubset</span> <span class="o">=</span> \
            <span class="n">azimuthal_integrator</span><span class="o">.</span><span class="n">integrate1d</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">,</span> 
                                             <span class="n">npt</span><span class="o">=</span><span class="n">num_bins</span><span class="p">,</span>
                                             <span class="n">radial_range</span><span class="o">=</span><span class="n">radial_range</span><span class="p">,</span>
                                             <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;r_mm&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bin_coords</span><span class="p">,</span> <span class="n">real_output_datasubset</span> <span class="o">=</span> \
            <span class="n">azimuthal_integrator</span><span class="o">.</span><span class="n">integrate1d</span><span class="p">(</span><span class="n">input_datasubset</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> 
                                             <span class="n">npt</span><span class="o">=</span><span class="n">num_bins</span><span class="p">,</span>
                                             <span class="n">radial_range</span><span class="o">=</span><span class="n">radial_range</span><span class="p">,</span>
                                             <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;r_mm&quot;</span><span class="p">)</span>
        <span class="n">bin_coords</span><span class="p">,</span> <span class="n">imag_output_datasubset</span> <span class="o">=</span> \
            <span class="n">azimuthal_integrator</span><span class="o">.</span><span class="n">integrate1d</span><span class="p">(</span><span class="n">input_datasubset</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> 
                                             <span class="n">npt</span><span class="o">=</span><span class="n">num_bins</span><span class="p">,</span>
                                             <span class="n">radial_range</span><span class="o">=</span><span class="n">radial_range</span><span class="p">,</span>
                                             <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;r_mm&quot;</span><span class="p">)</span>

        <span class="n">output_datasubset</span> <span class="o">=</span> <span class="n">real_output_datasubset</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">imag_output_datasubset</span>

    <span class="k">return</span> <span class="n">bin_coords</span><span class="p">,</span> <span class="n">output_datasubset</span>



<span class="k">def</span> <span class="nf">_update_output_signal_axes_v1</span><span class="p">(</span><span class="n">output_signal</span><span class="p">,</span> <span class="n">bin_coords</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_is_1d_signal</span><span class="p">(</span><span class="n">output_signal</span><span class="p">):</span>
        <span class="n">navigation_dims</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">axis_name</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">:</span> <span class="s2">&quot;$r$&quot;</span><span class="p">,</span> <span class="s2">&quot;1/&quot;</span><span class="p">:</span> <span class="s2">&quot;$k$&quot;</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">navigation_dims</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">axis_name</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">:</span> <span class="s2">&quot;$r_</span><span class="si">{xy}</span><span class="s2">$&quot;</span><span class="p">,</span> <span class="s2">&quot;1/&quot;</span><span class="p">:</span> <span class="s2">&quot;$k_</span><span class="si">{xy}</span><span class="s2">$&quot;</span><span class="p">}</span>
        
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">navigation_dims</span><span class="p">)):</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">output_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">update_from</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">output_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">name</span>

    <span class="n">units</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">units</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">hyperspy</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">UniformDataAxis</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_coords</span><span class="p">),</span>
                                         <span class="n">scale</span><span class="o">=</span><span class="n">bin_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">bin_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                         <span class="n">offset</span><span class="o">=</span><span class="n">bin_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                         <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">)</span>
    <span class="n">output_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">update_from</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">output_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">axis_name</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">None</span>



<div class="viewcode-block" id="OptionalAzimuthalIntegrationParams"><a class="viewcode-back" href="../_autosummary/empix.OptionalAzimuthalIntegrationParams.html#empix.OptionalAzimuthalIntegrationParams">[docs]</a><span class="k">class</span> <span class="nc">OptionalAzimuthalIntegrationParams</span><span class="p">(</span>
        <span class="n">fancytypes</span><span class="o">.</span><span class="n">PreSerializableAndUpdatable</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The set of optional parameters for the function</span>
<span class="sd">    :func:`empix.azimuthally_integrate`.</span>

<span class="sd">    The Python function :func:`empix.azimuthally_integrate` integrates</span>
<span class="sd">    azimuthally a given input 2D ``hyperspy`` signal. The Python function</span>
<span class="sd">    assumes that the input 2D ``hyperspy`` signal samples from a mathematical</span>
<span class="sd">    function :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` which is piecewise</span>
<span class="sd">    continuous in :math:`u_{x}` and :math:`u_{y}`, where :math:`u_{x}` and</span>
<span class="sd">    :math:`u_{y}` are the horizontal and vertical coordinates in the signal</span>
<span class="sd">    space of the input signal, and :math:`\mathbf{m}` is a vector of integers</span>
<span class="sd">    representing the navigation indices of the input signal. The Python function</span>
<span class="sd">    approximates the azimuthal integral of</span>
<span class="sd">    :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` given the input signal. We</span>
<span class="sd">    define the azimuthal integral of</span>
<span class="sd">    :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` as</span>

<span class="sd">    .. math ::</span>
<span class="sd">	&amp;S_{\mathbf{m}}\left(\left.R_{xy}=r_{xy}\right|</span>
<span class="sd">        0\le U_{\phi}&lt;2\pi;c_{x},c_{y}\right)\\&amp;\quad=</span>
<span class="sd">        \int_{0}^{2\pi}du_{\phi}\,r_{xy}</span>
<span class="sd">        F_{\mathbf{m}}\left(c_{x}+r_{xy}\cos\left(u_{\phi}\right),</span>
<span class="sd">        c_{y}+r_{xy}\sin\left(u_{\phi}\right)\right),</span>
<span class="sd">        :label: azimuthal_integral__1</span>

<span class="sd">    where :math:`\left(c_{x},c_{y}\right)` is the reference point from which the</span>
<span class="sd">    radial distance :math:`r_{xy}` is defined for the azimuthal integration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    center : `array_like` (`float`, shape=(2,)) | `None`, optional</span>
<span class="sd">        If ``center`` is set to ``None``, then the reference point</span>
<span class="sd">        :math:`\left(c_{x},c_{y}\right)`, from which the radial distance is</span>
<span class="sd">        defined for the azimuthal integration, is set to the signal space</span>
<span class="sd">        coordinates corresponding to the center signal space pixel.  Otherwise,</span>
<span class="sd">        if ``center`` is set to a pair of floating-point numbers, then</span>
<span class="sd">        ``center[0]`` and ``center[1]`` specify :math:`c_{x}` and :math:`c_{y}`</span>
<span class="sd">        respectively, in the same units of the corresponding signal space axes</span>
<span class="sd">        of the input signal.</span>
<span class="sd">    radial_range : `array_like` (`float`, shape=(2,)) | `None`, optional</span>
<span class="sd">        If ``radial_range`` is set to ``None``, then the radial range, over</span>
<span class="sd">        which the azimuthal integration is performed, is from zero to the largest</span>
<span class="sd">        radial distance within the signal space boundaries of the input signal</span>
<span class="sd">        for all azimuthal angles. Otherwise, if ``radial_range`` is set to a</span>
<span class="sd">        pair of floating-point numbers, then ``radial_range[0]`` and</span>
<span class="sd">        ``radial_range[1]`` specify the minimum and maximum radial distances of</span>
<span class="sd">        the radial range respectively, in the same units of the horizontal and</span>
<span class="sd">        vertical axes respectively of the signal space of the input signal. Note</span>
<span class="sd">        that in this case ``radial_range`` must satisfy</span>
<span class="sd">        ``0&lt;=radial_range[0]&lt;=radial_range[1]``. Moreover, the function</span>
<span class="sd">        represented by the input signal is assumed to be equal to zero</span>
<span class="sd">        everywhere outside of the signal space boundaries of said input signal.</span>
<span class="sd">    num_bins : `int` | `None`, optional</span>
<span class="sd">        ``num_bins`` must either be a positive integer or of the `NoneType`: if</span>
<span class="sd">        the former, then the dimension of the signal space of the output signal</span>
<span class="sd">        ``output_signal`` is set to ``num_bins``; if the latter, then the</span>
<span class="sd">        dimension of the signal space of ``output_signal`` is set to</span>
<span class="sd">        ``min(input_signal.data.shape[-2:])``, where ``input_signal`` is the</span>
<span class="sd">        input ``hyperspy`` signal.</span>
<span class="sd">    title : `str` | `None`, optional</span>
<span class="sd">        If ``title`` is set to ``None``, then the title of the output signal</span>
<span class="sd">        ``output_signal`` is set to ``&quot;Azimuthally Integrated &quot; +</span>
<span class="sd">        input_signal.metadata.General.title``, where ``input_signal`` is the </span>
<span class="sd">        input ``hyperspy`` signal.  Otherwise, if ``title`` is a `str`, then the</span>
<span class="sd">        ``output_signal.metadata.General.title`` is set to the value of </span>
<span class="sd">        ``title``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    core_attrs : `dict`, read-only</span>
<span class="sd">        A `dict` representation of the core attributes: each `dict` key is a</span>
<span class="sd">        `str` representing the name of a core attribute, and the corresponding</span>
<span class="sd">        `dict` value is the object to which said core attribute is set. The core</span>
<span class="sd">        attributes are the same as the construction parameters, except that </span>
<span class="sd">        their values might have been updated since construction.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_validation_and_conversion_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_center_v1</span><span class="p">,</span>
         <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_radial_range_v1</span><span class="p">,</span>
         <span class="s2">&quot;num_bins&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_num_bins_v1</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_title_v1</span><span class="p">}</span>

    <span class="n">_pre_serialization_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_center</span><span class="p">,</span>
         <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_radial_range</span><span class="p">,</span>
         <span class="s2">&quot;num_bins&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_num_bins</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_title</span><span class="p">}</span>

    <span class="n">_de_pre_serialization_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_center</span><span class="p">,</span>
         <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_radial_range</span><span class="p">,</span>
         <span class="s2">&quot;num_bins&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_num_bins</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_title</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">radial_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">num_bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">ctor_params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">center</span><span class="p">,</span>
                       <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">radial_range</span><span class="p">,</span>
                       <span class="s2">&quot;num_bins&quot;</span><span class="p">:</span> <span class="n">num_bins</span><span class="p">,</span>
                       <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">title</span><span class="p">}</span>
        <span class="n">fancytypes</span><span class="o">.</span><span class="n">PreSerializableAndUpdatable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctor_params</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="azimuthally_integrate"><a class="viewcode-back" href="../_autosummary/empix.azimuthally_integrate.html#empix.azimuthally_integrate">[docs]</a><span class="k">def</span> <span class="nf">azimuthally_integrate</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">optional_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Integrate azimuthally a given input 2D ``hyperspy`` signal.</span>

<span class="sd">    This current Python function assumes that the input 2D ``hyperspy`` signal</span>
<span class="sd">    samples from a mathematical function</span>
<span class="sd">    :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` which is piecewise continuous</span>
<span class="sd">    in :math:`u_{x}` and :math:`u_{y}`, where :math:`u_{x}` and :math:`u_{y}`</span>
<span class="sd">    are the horizontal and vertical coordinates in the signal space of the input</span>
<span class="sd">    signal, and :math:`\mathbf{m}` is a vector of integers representing the</span>
<span class="sd">    navigation indices of the input signal. The Python function approximates the</span>
<span class="sd">    azimuthal integral of :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` given</span>
<span class="sd">    the input signal. We define the azimuthal integral of</span>
<span class="sd">    :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` as</span>

<span class="sd">    .. math ::</span>
<span class="sd">	&amp;S_{\mathbf{m}}\left(\left.R_{xy}=r_{xy}\right|</span>
<span class="sd">        0\le U_{\phi}&lt;2\pi;c_{x},c_{y}\right)\\&amp;\quad=</span>
<span class="sd">        \int_{0}^{2\pi}du_{\phi}\,r_{xy}</span>
<span class="sd">        F_{\mathbf{m}}\left(c_{x}+r_{xy}\cos\left(u_{\phi}\right),</span>
<span class="sd">        c_{y}+r_{xy}\sin\left(u_{\phi}\right)\right),</span>
<span class="sd">        :label: azimuthal_integral__2</span>

<span class="sd">    where :math:`\left(c_{x},c_{y}\right)` is the reference point from which the</span>
<span class="sd">    radial distance :math:`r_{xy}` is defined for the azimuthal integration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_signal : :class:`hyperspy._signals.signal2d.Signal2D` | :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D`</span>
<span class="sd">        The input ``hyperspy`` signal.</span>
<span class="sd">    optional_params : :class:`empix.OptionalAzimuthalIntegrationParams` | `None`, optional</span>
<span class="sd">        The set of optional parameters. See the documentation for the class</span>
<span class="sd">        :class:`empix.OptionalAzimuthalIntegrationParams` for details. If</span>
<span class="sd">        ``optional_params`` is set to ``None``, rather than an instance of</span>
<span class="sd">        :class:`empix.OptionalAzimuthalIntegrationParams`, then the default</span>
<span class="sd">        values of the optional parameters are chosen.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output_signal : :class:`hyperspy._signals.signal1d.Signal1D` | :class:`hyperspy._signals.complex_signal1d.ComplexSignal1D`</span>
<span class="sd">        The output ``hyperspy`` signal that samples the azimuthal integral of</span>
<span class="sd">        the input signal ``input_signal``. Note that except for the title, the</span>
<span class="sd">        metadata of the output signal is determined from the metadata of the</span>
<span class="sd">        input signal.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">optional_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">optional_params</span> <span class="o">=</span> <span class="n">OptionalAzimuthalIntegrationParams</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optional_params</span><span class="p">,</span> <span class="n">OptionalAzimuthalIntegrationParams</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_azimuthally_integrate_err_msg_1</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">],</span>
              <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;radial_range&quot;</span><span class="p">],</span>
              <span class="s2">&quot;num_bins&quot;</span><span class="p">:</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;num_bins&quot;</span><span class="p">],</span>
              <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]}</span>
    <span class="n">temp_optional_params</span> <span class="o">=</span> <span class="n">OptionalAzimuthalAveragingParams</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="n">output_signal</span> <span class="o">=</span> <span class="n">azimuthally_average</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">temp_optional_params</span><span class="p">)</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">_default_title</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="s2">&quot;Azimuthally Integrated &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">output_signal</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">General</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">title</span>

    <span class="n">bin_coords</span> <span class="o">=</span> <span class="n">_bin_coords</span><span class="p">(</span><span class="n">output_signal</span><span class="p">)</span>
    <span class="n">navigation_rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">r_xy</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bin_coords</span><span class="p">):</span>
        <span class="n">multi_dim_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">navigation_rank</span> <span class="o">+</span> <span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">output_signal</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">multi_dim_slice</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r_xy</span>

    <span class="k">return</span> <span class="n">output_signal</span></div>



<span class="k">def</span> <span class="nf">_bin_coords</span><span class="p">(</span><span class="n">output_signal</span><span class="p">):</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">output_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">output_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">output_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
    <span class="n">bin_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">size</span><span class="o">*</span><span class="n">scale</span> <span class="o">-</span> <span class="mf">1e-10</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">bin_coords</span>



<div class="viewcode-block" id="OptionalAnnularAveragingParams"><a class="viewcode-back" href="../_autosummary/empix.OptionalAnnularAveragingParams.html#empix.OptionalAnnularAveragingParams">[docs]</a><span class="k">class</span> <span class="nc">OptionalAnnularAveragingParams</span><span class="p">(</span>
        <span class="n">fancytypes</span><span class="o">.</span><span class="n">PreSerializableAndUpdatable</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The set of optional parameters for the function</span>
<span class="sd">    :func:`empix.annularly_average`.</span>

<span class="sd">    The Python function :func:`empix.annularly_average` averages annularly a</span>
<span class="sd">    given input 2D ``hyperspy`` signal. The Python function assumes that the</span>
<span class="sd">    input 2D ``hyperspy`` signal samples from a mathematical function</span>
<span class="sd">    :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` which is piecewise continuous</span>
<span class="sd">    in :math:`u_{x}` and :math:`u_{y}`, where :math:`u_{x}` and :math:`u_{y}`</span>
<span class="sd">    are the horizontal and vertical coordinates in the signal space of the input</span>
<span class="sd">    signal, and :math:`\mathbf{m}` is a vector of integers representing the</span>
<span class="sd">    navigation indices of the input signal. The Python function approximates the</span>
<span class="sd">    azimuthal average of :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` given</span>
<span class="sd">    the input signal. We define the annular average of</span>
<span class="sd">    :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` as</span>

<span class="sd">    .. math ::</span>
<span class="sd">	&amp;\overline{S}_{\mathbf{m}}\left(\left.r_{xy,i}\le R&lt;r_{xy,f}\right|</span>
<span class="sd">        0\le U_{\phi}&lt;2\pi;c_{x},c_{y}\right)\\&amp;\quad</span>
<span class="sd">        =\frac{1}{\pi\left(r_{xy,f}^{2}-r_{xy,i}^{2}\right)}</span>
<span class="sd">        \int_{r_{xy,i}}^{r_{xy,f}}dr_{xy}\int_{0}^{2\pi}du_{\phi}\,r_{xy}</span>
<span class="sd">        F_{\mathbf{m}}\left(c_{x}+r_{xy}\cos\left(u_{\phi}\right),</span>
<span class="sd">        c_{y}+r_{xy}\sin\left(u_{\phi}\right)\right),</span>
<span class="sd">        :label: annular_average__1</span>

<span class="sd">    where :math:`\left(c_{x},c_{y}\right)` is the reference point from which the</span>
<span class="sd">    radial distance :math:`r_{xy}` is defined for the annular averaging.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    center : `array_like` (`float`, shape=(2,)) | `None`, optional</span>
<span class="sd">        If ``center`` is set to ``None``, then the reference point</span>
<span class="sd">        :math:`\left(c_{x},c_{y}\right)`, from which the radial distance is</span>
<span class="sd">        defined for the annular averaging, is set to the signal space</span>
<span class="sd">        coordinates corresponding to the center signal space pixel.  Otherwise,</span>
<span class="sd">        if ``center`` is set to a pair of floating-point numbers, then</span>
<span class="sd">        ``center[0]`` and ``center[1]`` specify :math:`c_{x}` and :math:`c_{y}`</span>
<span class="sd">        respectively, in the same units of the corresponding signal space axes</span>
<span class="sd">        of the input signal.</span>
<span class="sd">    radial_range : `array_like` (`float`, shape=(2,)) | `None`, optional</span>
<span class="sd">        If ``radial_range`` is set to ``None``, then the radial range, over</span>
<span class="sd">        which the annular averaging is performed, is from zero to the largest</span>
<span class="sd">        radial distance within the signal space boundaries of the input signal</span>
<span class="sd">        for all azimuthal angles. Otherwise, if ``radial_range`` is set to a</span>
<span class="sd">        pair of floating-point numbers, then ``radial_range[0]`` and</span>
<span class="sd">        ``radial_range[1]`` specify the minimum and maximum radial distances of</span>
<span class="sd">        the radial range respectively, in the same units of the horizontal and</span>
<span class="sd">        vertical axes respectively of the signal space of the input signal. Note</span>
<span class="sd">        that in this case ``radial_range`` must satisfy</span>
<span class="sd">        ``0&lt;=radial_range[0]&lt;=radial_range[1]``. Moreover, the function</span>
<span class="sd">        represented by the input signal is assumed to be equal to zero</span>
<span class="sd">        everywhere outside of the signal space boundaries of said input signal.</span>
<span class="sd">    title : `str` | `None`, optional</span>
<span class="sd">        If ``title`` is set to ``None``, then the title of the output signal</span>
<span class="sd">        ``output_signal`` is set to ``&quot;Annularly Averaged &quot; +</span>
<span class="sd">        input_signal.metadata.General.title``, where ``input_signal`` is the </span>
<span class="sd">        input ``hyperspy`` signal.  Otherwise, if ``title`` is a `str`, then the</span>
<span class="sd">        ``output_signal.metadata.General.title`` is set to the value of </span>
<span class="sd">        ``title``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    core_attrs : `dict`, read-only</span>
<span class="sd">        A `dict` representation of the core attributes: each `dict` key is a</span>
<span class="sd">        `str` representing the name of a core attribute, and the corresponding</span>
<span class="sd">        `dict` value is the object to which said core attribute is set. The core</span>
<span class="sd">        attributes are the same as the construction parameters, except that </span>
<span class="sd">        their values might have been updated since construction.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_validation_and_conversion_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_center_v1</span><span class="p">,</span>
         <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_radial_range_v1</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_title_v1</span><span class="p">}</span>

    <span class="n">_pre_serialization_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_center</span><span class="p">,</span>
         <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_radial_range</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_title</span><span class="p">}</span>

    <span class="n">_de_pre_serialization_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_center</span><span class="p">,</span>
         <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_radial_range</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_title</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">radial_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">ctor_params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">center</span><span class="p">,</span>
                       <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">radial_range</span><span class="p">,</span>
                       <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">title</span><span class="p">}</span>
        <span class="n">fancytypes</span><span class="o">.</span><span class="n">PreSerializableAndUpdatable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctor_params</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="annularly_average"><a class="viewcode-back" href="../_autosummary/empix.annularly_average.html#empix.annularly_average">[docs]</a><span class="k">def</span> <span class="nf">annularly_average</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">optional_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Average annularly a given input 2D ``hyperspy`` signal.</span>

<span class="sd">    This current Python function assumes that the input 2D ``hyperspy`` signal</span>
<span class="sd">    samples from a mathematical function</span>
<span class="sd">    :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` which is piecewise continuous</span>
<span class="sd">    in :math:`u_{x}` and :math:`u_{y}`, where :math:`u_{x}` and :math:`u_{y}`</span>
<span class="sd">    are the horizontal and vertical coordinates in the signal space of the input</span>
<span class="sd">    signal, and :math:`\mathbf{m}` is a vector of integers representing the</span>
<span class="sd">    navigation indices of the input signal. The Python function approximates the</span>
<span class="sd">    annular average of :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` given the</span>
<span class="sd">    input signal. We define the annular average of</span>
<span class="sd">    :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` as</span>

<span class="sd">    .. math ::</span>
<span class="sd">	&amp;\overline{S}_{\mathbf{m}}\left(\left.r_{xy,i}\le R&lt;r_{xy,f}\right|</span>
<span class="sd">        0\le U_{\phi}&lt;2\pi;c_{x},c_{y}\right)\\&amp;\quad</span>
<span class="sd">        =\frac{1}{\pi\left(r_{xy,f}^{2}-r_{xy,i}^{2}\right)}</span>
<span class="sd">        \int_{r_{xy,i}}^{r_{xy,f}}dr_{xy}\int_{0}^{2\pi}du_{\phi}\,r_{xy}</span>
<span class="sd">        F_{\mathbf{m}}\left(c_{x}+r_{xy}\cos\left(u_{\phi}\right),</span>
<span class="sd">        c_{y}+r_{xy}\sin\left(u_{\phi}\right)\right),</span>
<span class="sd">        :label: annular_average__2</span>

<span class="sd">    where :math:`\left(c_{x},c_{y}\right)` is the reference point from which the</span>
<span class="sd">    radial distance :math:`r_{xy}` is defined for the annular averaging.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_signal : :class:`hyperspy._signals.signal2d.Signal2D` | :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D`</span>
<span class="sd">        The input ``hyperspy`` signal.</span>
<span class="sd">    optional_params : :class:`empix.OptionalAnnularAveragingParams` | `None`, optional</span>
<span class="sd">        The set of optional parameters. See the documentation for the class</span>
<span class="sd">        :class:`empix.OptionalAnnularAveragingParams` for details. If</span>
<span class="sd">        ``optional_params`` is set to ``None``, rather than an instance of</span>
<span class="sd">        :class:`empix.OptionalAnnularAveragingParams`, then the default values </span>
<span class="sd">        of the optional parameters are chosen.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output_signal : :class:`hyperspy.signal.BaseSignal` | :class:`hyperspy._signals.complex_signal.ComplexSignal`</span>
<span class="sd">        The output ``hyperspy`` signal that samples the annular average of the</span>
<span class="sd">        input signal ``input_signal``. Note that except for the title, the</span>
<span class="sd">        metadata of the output signal is determined from the metadata of the</span>
<span class="sd">        input signal.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_2D_input_signal</span><span class="p">(</span><span class="n">input_signal</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">optional_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">optional_params</span> <span class="o">=</span> <span class="n">OptionalAnnularAveragingParams</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optional_params</span><span class="p">,</span> <span class="n">OptionalAnnularAveragingParams</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_annularly_average_err_msg_1</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">],</span>
              <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;radial_range&quot;</span><span class="p">],</span>
              <span class="s2">&quot;num_bins&quot;</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]),</span>
              <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]}</span>
    <span class="n">temp_optional_params</span> <span class="o">=</span> <span class="n">OptionalAzimuthalAveragingParams</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">temp_signal</span> <span class="o">=</span> <span class="n">azimuthally_average</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">temp_optional_params</span><span class="p">)</span>

    <span class="n">bin_coords</span> <span class="o">=</span> <span class="n">_bin_coords</span><span class="p">(</span><span class="n">temp_signal</span><span class="p">)</span>
    <span class="n">navigation_rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">r_xy</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bin_coords</span><span class="p">):</span>
        <span class="n">multi_dim_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">navigation_rank</span> <span class="o">+</span> <span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">temp_signal</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">multi_dim_slice</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r_xy</span>

    <span class="n">center</span> <span class="o">=</span> <span class="n">temp_optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">_check_and_convert_center_v2</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">)</span>

    <span class="n">radial_range</span> <span class="o">=</span> <span class="n">temp_optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;radial_range&quot;</span><span class="p">]</span>
    <span class="n">radial_range</span> <span class="o">=</span> <span class="n">_check_and_convert_radial_range_v2</span><span class="p">(</span><span class="n">radial_range</span><span class="p">,</span>
                                                      <span class="n">input_signal</span><span class="p">,</span>
                                                      <span class="n">center</span><span class="p">)</span>
    <span class="n">r_xy_i</span><span class="p">,</span> <span class="n">r_xy_f</span> <span class="o">=</span> <span class="p">(</span><span class="n">radial_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">1000</span><span class="p">,</span> <span class="n">radial_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span>
    <span class="n">area_of_annulus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">r_xy_f</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">r_xy_i</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>    
    <span class="n">r_xy_scale</span> <span class="o">=</span> <span class="n">temp_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span>

    <span class="n">output_signal</span> <span class="o">=</span> <span class="n">temp_signal</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">output_signal</span><span class="o">.</span><span class="n">data</span> <span class="o">*=</span> <span class="n">r_xy_scale</span> <span class="o">/</span> <span class="n">area_of_annulus</span>

    <span class="n">title</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">_default_title</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="s2">&quot;Annularly Averaged &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">output_signal</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">General</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">title</span>

    <span class="k">return</span> <span class="n">output_signal</span></div>



<div class="viewcode-block" id="OptionalAnnularIntegrationParams"><a class="viewcode-back" href="../_autosummary/empix.OptionalAnnularIntegrationParams.html#empix.OptionalAnnularIntegrationParams">[docs]</a><span class="k">class</span> <span class="nc">OptionalAnnularIntegrationParams</span><span class="p">(</span>
        <span class="n">fancytypes</span><span class="o">.</span><span class="n">PreSerializableAndUpdatable</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The set of optional parameters for the function</span>
<span class="sd">    :func:`empix.annularly_integrate`.</span>

<span class="sd">    The Python function :func:`empix.annularly_integrate` integrates annularly a</span>
<span class="sd">    given input 2D ``hyperspy`` signal. The Python function assumes that the</span>
<span class="sd">    input 2D ``hyperspy`` signal samples from a mathematical function</span>
<span class="sd">    :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` which is piecewise continuous</span>
<span class="sd">    in :math:`u_{x}` and :math:`u_{y}`, where :math:`u_{x}` and :math:`u_{y}`</span>
<span class="sd">    are the horizontal and vertical coordinates in the signal space of the input</span>
<span class="sd">    signal, and :math:`\mathbf{m}` is a vector of integers representing the</span>
<span class="sd">    navigation indices of the input signal. The Python function approximates the</span>
<span class="sd">    azimuthal average of :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` given</span>
<span class="sd">    the input signal. We define the annular average of</span>
<span class="sd">    :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` as</span>

<span class="sd">    .. math ::</span>
<span class="sd">	&amp;S_{\mathbf{m}}\left(\left.r_{xy,i}\le R&lt;r_{xy,f}\right|</span>
<span class="sd">        0\le U_{\phi}&lt;2\pi;c_{x},c_{y}\right)\\&amp;\quad</span>
<span class="sd">        =\int_{r_{xy,i}}^{r_{xy,f}}dr_{xy}\int_{0}^{2\pi}du_{\phi}\,r_{xy}</span>
<span class="sd">        F_{\mathbf{m}}\left(c_{x}+r_{xy}\cos\left(u_{\phi}\right),</span>
<span class="sd">        c_{y}+r_{xy}\sin\left(u_{\phi}\right)\right),</span>
<span class="sd">        :label: annular_integral__1</span>

<span class="sd">    where :math:`\left(c_{x},c_{y}\right)` is the reference point from which the</span>
<span class="sd">    radial distance :math:`r_{xy}` is defined for the annular integration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    center : `array_like` (`float`, shape=(2,)) | `None`, optional</span>
<span class="sd">        If ``center`` is set to ``None``, then the reference point</span>
<span class="sd">        :math:`\left(c_{x},c_{y}\right)`, from which the radial distance is</span>
<span class="sd">        defined for the annular integration, is set to the signal space</span>
<span class="sd">        coordinates corresponding to the center signal space pixel.  Otherwise,</span>
<span class="sd">        if ``center`` is set to a pair of floating-point numbers, then</span>
<span class="sd">        ``center[0]`` and ``center[1]`` specify :math:`c_{x}` and :math:`c_{y}`</span>
<span class="sd">        respectively, in the same units of the corresponding signal space axes</span>
<span class="sd">        of the input signal.</span>
<span class="sd">    radial_range : `array_like` (`float`, shape=(2,)) | `None`, optional</span>
<span class="sd">        If ``radial_range`` is set to ``None``, then the radial range, over</span>
<span class="sd">        which the annular integration is performed, is from zero to the largest</span>
<span class="sd">        radial distance within the signal space boundaries of the input signal</span>
<span class="sd">        for all azimuthal angles. Otherwise, if ``radial_range`` is set to a</span>
<span class="sd">        pair of floating-point numbers, then ``radial_range[0]`` and</span>
<span class="sd">        ``radial_range[1]`` specify the minimum and maximum radial distances of</span>
<span class="sd">        the radial range respectively, in the same units of the horizontal and</span>
<span class="sd">        vertical axes respectively of the signal space of the input signal. Note</span>
<span class="sd">        that in this case ``radial_range`` must satisfy</span>
<span class="sd">        ``0&lt;=radial_range[0]&lt;=radial_range[1]``. Moreover, the function</span>
<span class="sd">        represented by the input signal is assumed to be equal to zero</span>
<span class="sd">        everywhere outside of the signal space boundaries of said input signal.</span>
<span class="sd">    title : `str` | `None`, optional</span>
<span class="sd">        If ``title`` is set to ``None``, then the title of the output signal</span>
<span class="sd">        ``output_signal`` is set to ``&quot;Annularly Integrated &quot; +</span>
<span class="sd">        input_signal.metadata.General.title``, where ``input_signal`` is the </span>
<span class="sd">        input ``hyperspy`` signal.  Otherwise, if ``title`` is a `str`, then the</span>
<span class="sd">        ``output_signal.metadata.General.title`` is set to the value of </span>
<span class="sd">        ``title``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    core_attrs : `dict`, read-only</span>
<span class="sd">        A `dict` representation of the core attributes: each `dict` key is a</span>
<span class="sd">        `str` representing the name of a core attribute, and the corresponding</span>
<span class="sd">        `dict` value is the object to which said core attribute is set. The core</span>
<span class="sd">        attributes are the same as the construction parameters, except that </span>
<span class="sd">        their values might have been updated since construction.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_validation_and_conversion_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_center_v1</span><span class="p">,</span>
         <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_radial_range_v1</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_title_v1</span><span class="p">}</span>

    <span class="n">_pre_serialization_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_center</span><span class="p">,</span>
         <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_radial_range</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_title</span><span class="p">}</span>

    <span class="n">_de_pre_serialization_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_center</span><span class="p">,</span>
         <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_radial_range</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_title</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">radial_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">ctor_params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">center</span><span class="p">,</span>
                       <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">radial_range</span><span class="p">,</span>
                       <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">title</span><span class="p">}</span>
        <span class="n">fancytypes</span><span class="o">.</span><span class="n">PreSerializableAndUpdatable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctor_params</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="annularly_integrate"><a class="viewcode-back" href="../_autosummary/empix.annularly_integrate.html#empix.annularly_integrate">[docs]</a><span class="k">def</span> <span class="nf">annularly_integrate</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">optional_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Integrate annularly a given input 2D ``hyperspy`` signal.</span>

<span class="sd">    This current Python function assumes that the input 2D ``hyperspy`` signal</span>
<span class="sd">    samples from a mathematical function</span>
<span class="sd">    :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` which is piecewise continuous</span>
<span class="sd">    in :math:`u_{x}` and :math:`u_{y}`, where :math:`u_{x}` and :math:`u_{y}`</span>
<span class="sd">    are the horizontal and vertical coordinates in the signal space of the input</span>
<span class="sd">    signal, and :math:`\mathbf{m}` is a vector of integers representing the</span>
<span class="sd">    navigation indices of the input signal. The Python function approximates the</span>
<span class="sd">    annular integral of :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` given the</span>
<span class="sd">    input signal. We define the annular integral of</span>
<span class="sd">    :math:`F_{\mathbf{m}}\left(u_{x},u_{y}\right)` as</span>

<span class="sd">    .. math ::</span>
<span class="sd">	&amp;S_{\mathbf{m}}\left(\left.r_{xy,i}\le R&lt;r_{xy,f}\right|</span>
<span class="sd">        0\le U_{\phi}&lt;2\pi;c_{x},c_{y}\right)\\&amp;\quad</span>
<span class="sd">        =\int_{r_{xy,i}}^{r_{xy,f}}dr_{xy}\int_{0}^{2\pi}du_{\phi}\,r_{xy}</span>
<span class="sd">        F_{\mathbf{m}}\left(c_{x}+r_{xy}\cos\left(u_{\phi}\right),</span>
<span class="sd">        c_{y}+r_{xy}\sin\left(u_{\phi}\right)\right),</span>
<span class="sd">        :label: annular_integral__2</span>

<span class="sd">    where :math:`\left(c_{x},c_{y}\right)` is the reference point from which the</span>
<span class="sd">    radial distance :math:`r_{xy}` is defined for the annular integration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_signal : :class:`hyperspy._signals.signal2d.Signal2D` | :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D`</span>
<span class="sd">        The input ``hyperspy`` signal.</span>
<span class="sd">    optional_params : :class:`empix.OptionalAnnularIntegrationParams` | `None`, optional</span>
<span class="sd">        The set of optional parameters. See the documentation for the class</span>
<span class="sd">        :class:`empix.OptionalAnnularIntegrationParams` for details. If</span>
<span class="sd">        ``optional_params`` is set to ``None``, rather than an instance of</span>
<span class="sd">        :class:`empix.OptionalAnnularIntegrationParams`, then the default values</span>
<span class="sd">        of the optional parameters are chosen.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output_signal : :class:`hyperspy.signal.BaseSignal` | :class:`hyperspy._signals.complex_signal.ComplexSignal`</span>
<span class="sd">        The output ``hyperspy`` signal that samples the annular integral of the</span>
<span class="sd">        input signal ``input_signal``. Note that except for the title, the</span>
<span class="sd">        metadata of the output signal is determined from the metadata of the</span>
<span class="sd">        input signal.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_2D_input_signal</span><span class="p">(</span><span class="n">input_signal</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">optional_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">optional_params</span> <span class="o">=</span> <span class="n">OptionalAnnularIntegrationParams</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optional_params</span><span class="p">,</span> <span class="n">OptionalAnnularIntegrationParams</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_annularly_integrate_err_msg_1</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">],</span>
              <span class="s2">&quot;radial_range&quot;</span><span class="p">:</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;radial_range&quot;</span><span class="p">],</span>
              <span class="s2">&quot;num_bins&quot;</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]),</span>
              <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]}</span>
    <span class="n">temp_optional_params</span> <span class="o">=</span> <span class="n">OptionalAzimuthalIntegrationParams</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="n">integrated_azimuthally_signal</span> <span class="o">=</span> <span class="n">azimuthally_integrate</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span>
                                                          <span class="n">temp_optional_params</span><span class="p">)</span>
    <span class="n">r_xy_scale</span> <span class="o">=</span> <span class="n">integrated_azimuthally_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span>
    <span class="n">output_signal</span> <span class="o">=</span> <span class="n">integrated_azimuthally_signal</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">output_signal</span><span class="o">.</span><span class="n">data</span> <span class="o">*=</span> <span class="n">r_xy_scale</span>

    <span class="n">title</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">_default_title</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="s2">&quot;Annularly Integrated &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">output_signal</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">General</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">title</span>

    <span class="k">return</span> <span class="n">output_signal</span></div>



<span class="k">def</span> <span class="nf">_check_and_convert_limits_v1</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">):</span>
    <span class="n">limits</span> <span class="o">=</span> <span class="n">ctor_params</span><span class="p">[</span><span class="s2">&quot;limits&quot;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">limits</span> <span class="o">=</span> <span class="n">czekitout</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_pair_of_floats</span><span class="p">(</span><span class="n">limits</span><span class="p">,</span> <span class="s2">&quot;limits&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_check_and_convert_limits_v1_err_msg_1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">limits</span>



<span class="k">def</span> <span class="nf">_check_and_convert_normalize</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">):</span>
    <span class="n">normalize</span> <span class="o">=</span> <span class="n">czekitout</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_bool</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">[</span><span class="s2">&quot;normalize&quot;</span><span class="p">],</span> <span class="s2">&quot;normalize&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">normalize</span>



<span class="k">def</span> <span class="nf">_pre_serialize_limits</span><span class="p">(</span><span class="n">limits</span><span class="p">):</span>
    <span class="n">serializable_rep</span> <span class="o">=</span> <span class="n">limits</span>
    
    <span class="k">return</span> <span class="n">serializable_rep</span>



<span class="k">def</span> <span class="nf">_pre_serialize_normalize</span><span class="p">(</span><span class="n">normalize</span><span class="p">):</span>
    <span class="n">serializable_rep</span> <span class="o">=</span> <span class="n">normalize</span>
    
    <span class="k">return</span> <span class="n">serializable_rep</span>



<span class="k">def</span> <span class="nf">_de_pre_serialize_limits</span><span class="p">(</span><span class="n">serializable_rep</span><span class="p">):</span>
    <span class="n">limits</span> <span class="o">=</span> <span class="n">serializable_rep</span>

    <span class="k">return</span> <span class="n">limits</span>



<span class="k">def</span> <span class="nf">_de_pre_serialize_normalize</span><span class="p">(</span><span class="n">serializable_rep</span><span class="p">):</span>
    <span class="n">normalize</span> <span class="o">=</span> <span class="n">serializable_rep</span>

    <span class="k">return</span> <span class="n">normalize</span>



<div class="viewcode-block" id="OptionalCumulative1dIntegrationParams"><a class="viewcode-back" href="../_autosummary/empix.OptionalCumulative1dIntegrationParams.html#empix.OptionalCumulative1dIntegrationParams">[docs]</a><span class="k">class</span> <span class="nc">OptionalCumulative1dIntegrationParams</span><span class="p">(</span>
        <span class="n">fancytypes</span><span class="o">.</span><span class="n">PreSerializableAndUpdatable</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The set of optional parameters for the function</span>
<span class="sd">    :func:`empix.cumulatively_integrate_1d`.</span>

<span class="sd">    The Python function :func:`empix.cumulatively_integrate_1d` integrates</span>
<span class="sd">    cumulatively a given input 1D ``hyperspy`` signal. The Python function</span>
<span class="sd">    assumes that the input 1D ``hyperspy`` signal samples from a mathematical</span>
<span class="sd">    function :math:`F_{\mathbf{m}}\left(u\right)` which is piecewise continuous</span>
<span class="sd">    in :math:`u`, where :math:`u` is the signal space coordinate of the input</span>
<span class="sd">    signal, and :math:`\mathbf{m}` is a vector of integers representing the</span>
<span class="sd">    navigation indices of the input signal. The Python function approximates the</span>
<span class="sd">    cumulative integral of :math:`F_{\mathbf{m}}\left(u\right)` given the input</span>
<span class="sd">    signal. We define the cumulative integral of</span>
<span class="sd">    :math:`F_{\mathbf{m}}\left(u\right)` as</span>

<span class="sd">    .. math ::</span>
<span class="sd">	\text{CDF}_{\text{1D}}\left(u\right)&amp;=\int_{u_{i}}^{u}du^{\prime}\,</span>
<span class="sd">        F_{\mathbf{m}}\left(u^{\prime}\right),</span>
<span class="sd">        \\&amp;\quad u\in\left[\min\left(u_{i},u_{f}\right),</span>
<span class="sd">        \max\left(u_{i},u_{f}\right)\right],</span>
<span class="sd">        :label: cumulative_integral_1d__1</span>

<span class="sd">    where :math:`u_i` and :math:`u_f` specify the interval over which cumulative</span>
<span class="sd">    integration is performed, the interval being</span>
<span class="sd">    :math:`\left[\min\left(u_{i},u_{f}\right),</span>
<span class="sd">    \max\left(u_{i},u_{f}\right)\right]`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    limits : `array_like` (`float`, shape=(2,)) | `None`, optional</span>
<span class="sd">        If ``limits`` is set to ``None``, then the cumulative integration is</span>
<span class="sd">        performed over the entire input signal, with :math:`u_i&lt;u_f`. Otherwise,</span>
<span class="sd">        if ``limits`` is set to a pair of floating-point numbers, then</span>
<span class="sd">        ``limits[0]`` and ``limits[1]`` are :math:`u_i` and :math:`u_f`</span>
<span class="sd">        respectively, in the same units of the signal space coordinate</span>
<span class="sd">        :math:`u`. Note that the function represented by the input signal is</span>
<span class="sd">        assumed to be equal to zero everywhere outside of the bounds of said</span>
<span class="sd">        input signal.</span>
<span class="sd">    num_bins : `int` | `None`, optional</span>
<span class="sd">        ``num_bins`` must either be a positive integer or of the `NoneType`: if</span>
<span class="sd">        the former, then the dimension of the signal space of the output signal</span>
<span class="sd">        ``output_signal`` is set to ``num_bins``; if the latter, then the</span>
<span class="sd">        dimension of the signal space of ``output_signal`` is set to</span>
<span class="sd">        ``input_signal.data[-1]``, where ``input_signal`` is the input</span>
<span class="sd">        ``hyperspy`` signal.</span>
<span class="sd">    normalize : `bool`, optional</span>
<span class="sd">        If ``normalize`` is set to ``True``, then the cumulative integral is</span>
<span class="sd">        normalized such that</span>
<span class="sd">        :math:`\text{CDF}_{\text{1D}}\left(u=u_f\right)`. Otherwise, if</span>
<span class="sd">        ``normalize`` is set to ``False``, then the cumulative integral is not</span>
<span class="sd">        normalized.</span>
<span class="sd">    title : `str` | `None`, optional</span>
<span class="sd">        If ``title`` is set to ``None``, then the title of the output signal</span>
<span class="sd">        ``output_signal`` is set to ``&quot;CDF(&quot;+</span>
<span class="sd">        input_signal.metadata.General.title+&quot;)&quot;``, where ``input_signal`` is the</span>
<span class="sd">        input ``hyperspy`` signal.  Otherwise, if ``title`` is a `str`, then the</span>
<span class="sd">        ``output_signal.metadata.General.title`` is set to the value of </span>
<span class="sd">        ``title``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    core_attrs : `dict`, read-only</span>
<span class="sd">        A `dict` representation of the core attributes: each `dict` key is a</span>
<span class="sd">        `str` representing the name of a core attribute, and the corresponding</span>
<span class="sd">        `dict` value is the object to which said core attribute is set. The core</span>
<span class="sd">        attributes are the same as the construction parameters, except that </span>
<span class="sd">        their values might have been updated since construction.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_validation_and_conversion_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;limits&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_limits_v1</span><span class="p">,</span>
         <span class="s2">&quot;num_bins&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_num_bins_v1</span><span class="p">,</span>
         <span class="s2">&quot;normalize&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_normalize</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_title_v1</span><span class="p">}</span>

    <span class="n">_pre_serialization_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;limits&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_limits</span><span class="p">,</span>
         <span class="s2">&quot;num_bins&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_num_bins</span><span class="p">,</span>
         <span class="s2">&quot;normalize&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_normalize</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_title</span><span class="p">}</span>

    <span class="n">_de_pre_serialization_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;limits&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_limits</span><span class="p">,</span>
         <span class="s2">&quot;num_bins&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_num_bins</span><span class="p">,</span>
         <span class="s2">&quot;normalize&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_normalize</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_title</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">limits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">num_bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">ctor_params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;limits&quot;</span><span class="p">:</span> <span class="n">limits</span><span class="p">,</span>
                       <span class="s2">&quot;num_bins&quot;</span><span class="p">:</span> <span class="n">num_bins</span><span class="p">,</span>
                       <span class="s2">&quot;normalize&quot;</span><span class="p">:</span> <span class="n">normalize</span><span class="p">,</span>
                       <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">title</span><span class="p">}</span>
        <span class="n">fancytypes</span><span class="o">.</span><span class="n">PreSerializableAndUpdatable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctor_params</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="cumulatively_integrate_1d"><a class="viewcode-back" href="../_autosummary/empix.cumulatively_integrate_1d.html#empix.cumulatively_integrate_1d">[docs]</a><span class="k">def</span> <span class="nf">cumulatively_integrate_1d</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">optional_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Integrate cumulatively a given input 1D ``hyperspy`` signal.</span>

<span class="sd">    This current Python function assumes that the input 1D ``hyperspy`` signal</span>
<span class="sd">    samples from a mathematical</span>
<span class="sd">    function :math:`F_{\mathbf{m}}\left(u\right)` which is piecewise continuous</span>
<span class="sd">    in :math:`u`, where :math:`u` is the signal space coordinate of the input</span>
<span class="sd">    signal, and :math:`\mathbf{m}` is a vector of integers representing the</span>
<span class="sd">    navigation indices of the input signal. The Python function approximates the</span>
<span class="sd">    cumulative integral of :math:`F_{\mathbf{m}}\left(u\right)` given the input</span>
<span class="sd">    signal. We define the cumulative integral of</span>
<span class="sd">    :math:`F_{\mathbf{m}}\left(u\right)` as</span>

<span class="sd">    .. math ::</span>
<span class="sd">	\text{CDF}_{\text{1D}}\left(u\right)&amp;=\int_{u_{i}}^{u}du^{\prime}\,</span>
<span class="sd">        F_{\mathbf{m}}\left(u^{\prime}\right),</span>
<span class="sd">        \\&amp;\quad u\in\left[\min\left(u_{i},u_{f}\right),</span>
<span class="sd">        \max\left(u_{i},u_{f}\right)\right],</span>
<span class="sd">        :label: cumulative_integral_1d__2</span>

<span class="sd">    where :math:`u_i` and :math:`u_f` specify the interval over which cumulative</span>
<span class="sd">    integration is performed, the interval being</span>
<span class="sd">    :math:`\left[\min\left(u_{i},u_{f}\right),</span>
<span class="sd">    \max\left(u_{i},u_{f}\right)\right]`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_signal : :class:`hyperspy._signals.signal1d.Signal1D` | :class:`hyperspy._signals.complex_signal1d.ComplexSignal1D`</span>
<span class="sd">        The input ``hyperspy`` signal.</span>
<span class="sd">    optional_params : :class:`empix.OptionalCumulative1dIntegrationParams` | `None`, optional</span>
<span class="sd">        The set of optional parameters. See the documentation for the class</span>
<span class="sd">        :class:`empix.OptionalCumulative1dIntegrationParams` for details. If</span>
<span class="sd">        ``optional_params`` is set to ``None``, rather than an instance of</span>
<span class="sd">        :class:`empix.OptionalCumulative1dIntegrationParams`, then the default </span>
<span class="sd">        values of the optional parameters are chosen.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output_signal : :class:`hyperspy._signals.signal1d.Signal1D` | :class:`hyperspy._signals.complex_signal1d.ComplexSignal1D`</span>
<span class="sd">        The output ``hyperspy`` signal that samples the annular integral of the</span>
<span class="sd">        input signal ``input_signal``. Note that except for the title, the</span>
<span class="sd">        metadata of the output signal is determined from the metadata of the</span>
<span class="sd">        input signal.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_1D_input_signal</span><span class="p">(</span><span class="n">input_signal</span><span class="p">)</span>
    <span class="n">limits</span><span class="p">,</span> <span class="n">num_bins</span><span class="p">,</span> <span class="n">normalize</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> \
        <span class="n">_check_and_convert_optional_params_v2</span><span class="p">(</span><span class="n">optional_params</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">_default_title</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="s2">&quot;CDF(&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>

    <span class="n">u_coords</span> <span class="o">=</span> <span class="n">_u_coords_1d</span><span class="p">(</span><span class="n">input_signal</span><span class="p">)</span>
    <span class="n">beg_u_coord_idx</span><span class="p">,</span> <span class="n">end_u_coord_idx</span> <span class="o">=</span> <span class="n">_beg_and_end_u_coord_indices</span><span class="p">(</span><span class="n">u_coords</span><span class="p">,</span>
                                                                    <span class="n">limits</span><span class="p">)</span>

    <span class="n">navigation_dims</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">output_data_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">navigation_dims</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">num_bins</span><span class="p">]</span>
    <span class="n">output_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">output_data_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">num_patterns</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">navigation_dims</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">pattern_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_patterns</span><span class="p">):</span>
        <span class="n">navigation_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">pattern_idx</span><span class="p">,</span> <span class="n">navigation_dims</span><span class="p">)</span>
        <span class="n">input_datasubset</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">navigation_indices</span><span class="p">]</span>
            
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;input_datasubset&quot;</span><span class="p">:</span> <span class="n">input_datasubset</span><span class="p">,</span>
                  <span class="s2">&quot;u_coords&quot;</span><span class="p">:</span> <span class="n">u_coords</span><span class="p">,</span>
                  <span class="s2">&quot;beg_u_coord_idx&quot;</span><span class="p">:</span> <span class="n">beg_u_coord_idx</span><span class="p">,</span>
                  <span class="s2">&quot;end_u_coord_idx&quot;</span><span class="p">:</span> <span class="n">end_u_coord_idx</span><span class="p">,</span>
                  <span class="s2">&quot;limits&quot;</span><span class="p">:</span> <span class="n">limits</span><span class="p">,</span>
                  <span class="s2">&quot;num_bins&quot;</span><span class="p">:</span> <span class="n">num_bins</span><span class="p">,</span>
                  <span class="s2">&quot;normalize&quot;</span><span class="p">:</span> <span class="n">normalize</span><span class="p">}</span>
        <span class="n">bin_coords</span><span class="p">,</span> <span class="n">output_datasubset</span> <span class="o">=</span> \
            <span class="n">_cumulatively_integrate_input_datasubset</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">output_data</span><span class="p">[</span><span class="n">navigation_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_datasubset</span>
        
    <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;General&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">title</span><span class="p">},</span> <span class="s2">&quot;Signal&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">()}</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">output_data</span><span class="p">):</span>
        <span class="n">output_signal</span> <span class="o">=</span> <span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal1D</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">output_data</span><span class="p">,</span>
                                                  <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output_signal</span> <span class="o">=</span> <span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">ComplexSignal1D</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">output_data</span><span class="p">,</span>
                                                         <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>
    <span class="n">_update_output_signal_axes_v1</span><span class="p">(</span><span class="n">output_signal</span><span class="p">,</span> <span class="n">bin_coords</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output_signal</span></div>



<span class="k">def</span> <span class="nf">_check_1D_input_signal</span><span class="p">(</span><span class="n">input_signal</span><span class="p">):</span>
    <span class="n">accepted_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal1D</span><span class="p">,</span>
                      <span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">ComplexSignal1D</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;obj&quot;</span><span class="p">:</span> <span class="n">input_signal</span><span class="p">,</span>
              <span class="s2">&quot;obj_name&quot;</span><span class="p">:</span> <span class="s2">&quot;input_signal&quot;</span><span class="p">,</span>
              <span class="s2">&quot;accepted_types&quot;</span><span class="p">:</span> <span class="n">accepted_types</span><span class="p">}</span>
    <span class="n">czekitout</span><span class="o">.</span><span class="n">check</span><span class="o">.</span><span class="n">if_instance_of_any_accepted_types</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">input_signal</span>



<span class="k">def</span> <span class="nf">_check_and_convert_optional_params_v2</span><span class="p">(</span><span class="n">optional_params</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">optional_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">optional_params</span> <span class="o">=</span> <span class="n">OptionalCumulative1dIntegrationParams</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optional_params</span><span class="p">,</span> <span class="n">OptionalCumulative1dIntegrationParams</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_check_and_convert_optional_params_v2_err_msg_1</span><span class="p">)</span>

    <span class="n">limits</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;limits&quot;</span><span class="p">]</span>
    <span class="n">limits</span> <span class="o">=</span> <span class="n">_check_and_convert_limits_v2</span><span class="p">(</span><span class="n">limits</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">)</span>

    <span class="n">num_bins</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;num_bins&quot;</span><span class="p">]</span>
    <span class="n">num_bins</span> <span class="o">=</span> <span class="n">_check_and_convert_num_bins_v2</span><span class="p">(</span><span class="n">num_bins</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">)</span>

    <span class="n">normalize</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;normalize&quot;</span><span class="p">]</span>

    <span class="n">title</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">limits</span><span class="p">,</span> <span class="n">num_bins</span><span class="p">,</span> <span class="n">normalize</span><span class="p">,</span> <span class="n">title</span>



<span class="k">def</span> <span class="nf">_check_and_convert_limits_v2</span><span class="p">(</span><span class="n">limits</span><span class="p">,</span> <span class="n">signal</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">limits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">u_coords</span> <span class="o">=</span> <span class="n">_u_coords_1d</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
        <span class="n">u_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">u_coords</span><span class="p">)</span>
        <span class="n">u_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">u_coords</span><span class="p">)</span>
        <span class="n">limits</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_i</span><span class="p">,</span> <span class="n">u_f</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">limits</span>



<span class="k">def</span> <span class="nf">_u_coords_1d</span><span class="p">(</span><span class="n">signal</span><span class="p">):</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
    <span class="n">u_coords</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">u_coords</span>



<span class="k">def</span> <span class="nf">_beg_and_end_u_coord_indices</span><span class="p">(</span><span class="n">u_coords</span><span class="p">,</span> <span class="n">limits</span><span class="p">):</span>
    <span class="n">du</span> <span class="o">=</span> <span class="n">u_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">idx_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_coords</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">limits</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
    <span class="n">idx_1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">idx_1</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">du</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">min</span><span class="p">(</span><span class="n">idx_1</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">u_coords</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">idx_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_coords</span><span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">limits</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
    <span class="n">idx_2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">idx_2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">u_coords</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">du</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">max</span><span class="p">(</span><span class="n">idx_2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    
    <span class="n">beg_u_coord_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">idx_1</span><span class="p">,</span> <span class="n">idx_2</span><span class="p">)</span>
    <span class="n">end_u_coord_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">idx_1</span><span class="p">,</span> <span class="n">idx_2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">beg_u_coord_idx</span><span class="p">,</span> <span class="n">end_u_coord_idx</span>



<span class="k">def</span> <span class="nf">_cumulatively_integrate_input_datasubset</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">,</span>
                                             <span class="n">u_coords</span><span class="p">,</span>
                                             <span class="n">beg_u_coord_idx</span><span class="p">,</span>
                                             <span class="n">end_u_coord_idx</span><span class="p">,</span>
                                             <span class="n">limits</span><span class="p">,</span>
                                             <span class="n">num_bins</span><span class="p">,</span>
                                             <span class="n">normalize</span><span class="p">):</span>
    <span class="n">du</span> <span class="o">=</span> <span class="n">u_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">u_coords</span><span class="p">[</span><span class="n">beg_u_coord_idx</span><span class="p">:</span><span class="n">end_u_coord_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">input_datasubset</span><span class="p">[</span><span class="n">beg_u_coord_idx</span><span class="p">:</span><span class="n">end_u_coord_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">du</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">F</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                                   <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                   <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">u_i</span><span class="p">,</span> <span class="n">u_f</span> <span class="o">=</span> <span class="n">limits</span>
    <span class="n">bin_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">u_i</span><span class="p">,</span> <span class="n">u_f</span><span class="p">,</span> <span class="n">num_bins</span><span class="p">)</span>
    <span class="n">F_data</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">bin_coords</span><span class="p">)</span>

    <span class="n">output_datasubset</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">du</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">F_data</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">output_datasubset</span> <span class="o">/=</span> <span class="n">output_datasubset</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">bin_coords</span><span class="p">,</span> <span class="n">output_datasubset</span>



<span class="k">def</span> <span class="nf">_check_and_convert_window_dims_v1</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">):</span>
    <span class="n">window_dims</span> <span class="o">=</span> <span class="n">ctor_params</span><span class="p">[</span><span class="s2">&quot;window_dims&quot;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">window_dims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">window_dims</span> <span class="o">=</span> \
                <span class="n">czekitout</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_pair_of_positive_ints</span><span class="p">(</span><span class="n">window_dims</span><span class="p">,</span>
                                                           <span class="s2">&quot;window_dims&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_check_and_convert_window_dims_v1_err_msg_1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">window_dims</span>



<span class="k">def</span> <span class="nf">_check_and_convert_pad_mode</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">):</span>
    <span class="n">pad_mode</span> <span class="o">=</span> <span class="n">ctor_params</span><span class="p">[</span><span class="s2">&quot;pad_mode&quot;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">pad_mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pad_mode</span> <span class="o">=</span> <span class="n">czekitout</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_str_from_str_like</span><span class="p">(</span><span class="n">pad_mode</span><span class="p">,</span>
                                                              <span class="s2">&quot;pad_mode&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_check_and_convert_pad_mode_err_msg_1</span><span class="p">)</span>

        <span class="n">accepted_values</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;no-padding&quot;</span><span class="p">,</span> <span class="s2">&quot;wrap&quot;</span><span class="p">,</span> <span class="s2">&quot;zeros&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pad_mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">accepted_values</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_check_and_convert_pad_mode_err_msg_1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pad_mode</span>



<span class="k">def</span> <span class="nf">_check_and_convert_apply_symmetric_mask</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">):</span>
    <span class="n">apply_symmetric_mask</span> <span class="o">=</span> \
        <span class="n">czekitout</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_bool</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">[</span><span class="s2">&quot;apply_symmetric_mask&quot;</span><span class="p">],</span>
                                  <span class="s2">&quot;apply_symmetric_mask&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">apply_symmetric_mask</span>



<span class="k">def</span> <span class="nf">_pre_serialize_window_dims</span><span class="p">(</span><span class="n">window_dims</span><span class="p">):</span>
    <span class="n">serializable_rep</span> <span class="o">=</span> <span class="n">window_dims</span>
    
    <span class="k">return</span> <span class="n">serializable_rep</span>



<span class="k">def</span> <span class="nf">_pre_serialize_pad_mode</span><span class="p">(</span><span class="n">pad_mode</span><span class="p">):</span>
    <span class="n">serializable_rep</span> <span class="o">=</span> <span class="n">pad_mode</span>
    
    <span class="k">return</span> <span class="n">serializable_rep</span>



<span class="k">def</span> <span class="nf">_pre_serialize_apply_symmetric_mask</span><span class="p">(</span><span class="n">apply_symmetric_mask</span><span class="p">):</span>
    <span class="n">serializable_rep</span> <span class="o">=</span> <span class="n">apply_symmetric_mask</span>
    
    <span class="k">return</span> <span class="n">serializable_rep</span>



<span class="k">def</span> <span class="nf">_de_pre_serialize_window_dims</span><span class="p">(</span><span class="n">serializable_rep</span><span class="p">):</span>
    <span class="n">window_dims</span> <span class="o">=</span> <span class="n">serializable_rep</span>

    <span class="k">return</span> <span class="n">window_dims</span>



<span class="k">def</span> <span class="nf">_de_pre_serialize_pad_mode</span><span class="p">(</span><span class="n">serializable_rep</span><span class="p">):</span>
    <span class="n">pad_mode</span> <span class="o">=</span> <span class="n">serializable_rep</span>

    <span class="k">return</span> <span class="n">pad_mode</span>



<span class="k">def</span> <span class="nf">_de_pre_serialize_apply_symmetric_mask</span><span class="p">(</span><span class="n">serializable_rep</span><span class="p">):</span>
    <span class="n">apply_symmetric_mask</span> <span class="o">=</span> <span class="n">serializable_rep</span>

    <span class="k">return</span> <span class="n">apply_symmetric_mask</span>



<div class="viewcode-block" id="OptionalCroppingParams"><a class="viewcode-back" href="../_autosummary/empix.OptionalCroppingParams.html#empix.OptionalCroppingParams">[docs]</a><span class="k">class</span> <span class="nc">OptionalCroppingParams</span><span class="p">(</span><span class="n">fancytypes</span><span class="o">.</span><span class="n">PreSerializableAndUpdatable</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The set of optional parameters for the function :func:`empix.crop`.</span>

<span class="sd">    The Python function :func:`empix.crop` applies a series of optional</span>
<span class="sd">    transformations to a given input 2D ``hyperspy`` signal. Let us denote the</span>
<span class="sd">    input 2D ``hyperspy`` signal by :math:`F_{\mathbf{m}; l_x, l_y}`, where</span>
<span class="sd">    :math:`l_x` and :math:`l_y` are integers indexing the sampled horizontal and</span>
<span class="sd">    vertical coordinates respectively in the signal space of the input signal,</span>
<span class="sd">    and :math:`\mathbf{m}` is a vector of integers representing the navigation</span>
<span class="sd">    indices of the input signal. The Python function effectively does the</span>
<span class="sd">    following:</span>

<span class="sd">    1. Copies the input signal and optionally pads the copy along the horizontal</span>
<span class="sd">    and vertical axes in signal space according to the parameter ``pad_mode``;</span>

<span class="sd">    2. Constructs a cropping window in the signal space of the (optionally</span>
<span class="sd">    padded) copy of the input signal, with the cropping window dimensions being</span>
<span class="sd">    determined by the parameter ``window_dims``;</span>

<span class="sd">    3. Shifts the center of the cropping window to coordinates determined by the</span>
<span class="sd">    parameter ``center``;</span>

<span class="sd">    4. Shifts the center of the cropping window again to the coordinates of the</span>
<span class="sd">    pixel closest to the aforementioned coordinates in the previous step;</span>

<span class="sd">    5. Crops the (optionally padded) copy of the input signal along the</span>
<span class="sd">    horizontal and vertical dimensions of the signal space according to the</span>
<span class="sd">    placement of the cropping window in the previous two steps;</span>

<span class="sd">    6. Optionally applies a symmetric mask to the cropped signal resulting from</span>
<span class="sd">    the previous step according to the parameter ``apply_symmetric_mask``.</span>

<span class="sd">    See the description below of the optional parameters for more details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    center : `array_like` (`float`, shape=(2,)) | `None`, optional</span>
<span class="sd">        If ``center`` is set to ``None``, then the center of the cropping window</span>
<span class="sd">        is set to the signal space coordinates corresponding to the center</span>
<span class="sd">        signal space pixel of the original input signal. Otherwise, if</span>
<span class="sd">        ``center`` is set to a pair of floating-point numbers, then</span>
<span class="sd">        ``center[0]`` and ``center[1]`` specify the horizontal and vertical</span>
<span class="sd">        signal space coordinates of the center of the cropping window prior to</span>
<span class="sd">        the subpixel shift to the nearest pixel, in the same units of the</span>
<span class="sd">        corresponding axes of the input signal</span>
<span class="sd">    window_dims : `array_like` (`int`, shape=(2,)) | `None`, optional</span>
<span class="sd">        If ``window_dims`` is set to ``None``, then the dimensions of the</span>
<span class="sd">        cropping window are set to the dimensions of the signal space of the</span>
<span class="sd">        input signal.  Otherwise, if ``window_dims`` is set to a pair of</span>
<span class="sd">        positive integers, then ``window_dims[0]`` and ``window_dims[1]``</span>
<span class="sd">        specify the horizontal and vertical dimensions of the cropping window in</span>
<span class="sd">        units of pixels.</span>
<span class="sd">    pad_mode : ``&quot;no-padding&quot;`` | ``&quot;wrap&quot;`` | ``&quot;zeros&quot;``, optional</span>
<span class="sd">        If ``pad_mode`` is set to ``&quot;no-padding&quot;``, then no padding is performed</span>
<span class="sd">        prior to the crop. If ``pad_mode`` is set to ``&quot;wrap&quot;``, then the copy</span>
<span class="sd">        of the input signal is effectively padded along the horizontal and</span>
<span class="sd">        vertical axes in signal space by tiling the copy both horizontally and</span>
<span class="sd">        vertically in signal space such that the cropping window lies completely</span>
<span class="sd">        within the signal space boundaries of the resulting padded signal upon</span>
<span class="sd">        performing the crop. If ``pad_mode`` is set to ``&quot;zeros&quot;``, then the</span>
<span class="sd">        copy of the input signal is effectively padded with zeros such that the</span>
<span class="sd">        cropping window lies completely within the signal space boundaries of</span>
<span class="sd">        the resulting padded signal upon performing the crop.</span>
<span class="sd">    apply_symmetric_mask : `bool`, optional</span>
<span class="sd">        If ``apply_symmetric_mask`` is set to ``True`` and ``pad_mode`` to</span>
<span class="sd">        ``&quot;zeros&quot;``, then for every signal space pixel in the cropped signal</span>
<span class="sd">        that has a value of zero due to padding and a corresponding pixel with</span>
<span class="sd">        coordinates equal to the former after a rotation of 180 degrees about</span>
<span class="sd">        the center of the cropped signal, the latter i.e. the aforementioned</span>
<span class="sd">        corresponding pixel is effectively set to zero. The effective procedure</span>
<span class="sd">        is equivalent to applying a symmetric mask. Otherwise, no mask is</span>
<span class="sd">        effectively applied after cropping.</span>
<span class="sd">    title : `str` | `None`, optional</span>
<span class="sd">        If ``title`` is set to ``None``, then the title of the output signal</span>
<span class="sd">        ``output_signal`` is set to ``&quot;Cropped &quot;+</span>
<span class="sd">        input_signal.metadata.General.title``, where ``input_signal`` is the</span>
<span class="sd">        input ``hyperspy`` signal.  Otherwise, if ``title`` is a `str`, then the</span>
<span class="sd">        ``output_signal.metadata.General.title`` is set to the value of</span>
<span class="sd">        ``title``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    core_attrs : `dict`, read-only</span>
<span class="sd">        A `dict` representation of the core attributes: each `dict` key is a</span>
<span class="sd">        `str` representing the name of a core attribute, and the corresponding</span>
<span class="sd">        `dict` value is the object to which said core attribute is set. The core</span>
<span class="sd">        attributes are the same as the construction parameters, except that </span>
<span class="sd">        their values might have been updated since construction.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_validation_and_conversion_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_center_v1</span><span class="p">,</span>
         <span class="s2">&quot;window_dims&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_window_dims_v1</span><span class="p">,</span>
         <span class="s2">&quot;pad_mode&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_pad_mode</span><span class="p">,</span>
         <span class="s2">&quot;apply_symmetric_mask&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_apply_symmetric_mask</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_title_v1</span><span class="p">}</span>

    <span class="n">_pre_serialization_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_center</span><span class="p">,</span>
         <span class="s2">&quot;window_dims&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_window_dims</span><span class="p">,</span>
         <span class="s2">&quot;pad_mode&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_pad_mode</span><span class="p">,</span>
         <span class="s2">&quot;apply_symmetric_mask&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_apply_symmetric_mask</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_title</span><span class="p">}</span>

    <span class="n">_de_pre_serialization_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_center</span><span class="p">,</span>
         <span class="s2">&quot;window_dims&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_window_dims</span><span class="p">,</span>
         <span class="s2">&quot;pad_mode&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_pad_mode</span><span class="p">,</span>
         <span class="s2">&quot;apply_symmetric_mask&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_apply_symmetric_mask</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_title</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">window_dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;no-padding&quot;</span><span class="p">,</span>
                 <span class="n">apply_symmetric_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">ctor_params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="n">center</span><span class="p">,</span>
                       <span class="s2">&quot;window_dims&quot;</span><span class="p">:</span> <span class="n">window_dims</span><span class="p">,</span>
                       <span class="s2">&quot;pad_mode&quot;</span><span class="p">:</span> <span class="n">pad_mode</span><span class="p">,</span>
                       <span class="s2">&quot;apply_symmetric_mask&quot;</span><span class="p">:</span> <span class="n">apply_symmetric_mask</span><span class="p">,</span>
                       <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">title</span><span class="p">}</span>
        <span class="n">fancytypes</span><span class="o">.</span><span class="n">PreSerializableAndUpdatable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctor_params</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="crop"><a class="viewcode-back" href="../_autosummary/empix.crop.html#empix.crop">[docs]</a><span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">optional_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Crop a given input 2D ``hyperspy`` signal.</span>

<span class="sd">    This current Python function applies a series of optional transformations to</span>
<span class="sd">    a given input 2D ``hyperspy`` signal. Let us denote the input 2D</span>
<span class="sd">    ``hyperspy`` signal by :math:`F_{\mathbf{m}; l_x, l_y}`, where :math:`l_x`</span>
<span class="sd">    and :math:`l_y` are integers indexing the sampled horizontal and vertical</span>
<span class="sd">    coordinates respectively in the signal space of the input signal, and</span>
<span class="sd">    :math:`\mathbf{m}` is a vector of integers representing the navigation</span>
<span class="sd">    indices of the input signal. The Python function effectively does the</span>
<span class="sd">    following:</span>

<span class="sd">    1. Copies the input signal and optionally pads the copy along the horizontal</span>
<span class="sd">    and vertical axes in signal space according to the parameter ``pad_mode``;</span>

<span class="sd">    2. Constructs a cropping window in the signal space of the (optionally</span>
<span class="sd">    padded) copy of the input signal, with the cropping window dimensions being</span>
<span class="sd">    determined by the parameter ``window_dims``;</span>

<span class="sd">    3. Shifts the center of the cropping window to coordinates determined by the</span>
<span class="sd">    parameter ``center``;</span>

<span class="sd">    4. Shifts the center of the cropping window again to the coordinates of the</span>
<span class="sd">    pixel closest to the aforementioned coordinates in the previous step;</span>

<span class="sd">    5. Crops the (optionally padded) copy of the input signal along the</span>
<span class="sd">    horizontal and vertical dimensions of the signal space according to the</span>
<span class="sd">    placement of the cropping window in the previous two steps;</span>

<span class="sd">    6. Optionally applies a symmetric mask to the cropped signal resulting from</span>
<span class="sd">    the previous step according to the parameter ``apply_symmetric_mask``.</span>

<span class="sd">    See the description below of the optional parameters for more details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_signal : :class:`hyperspy._signals.signal2d.Signal2D` | :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D`</span>
<span class="sd">        The input ``hyperspy`` signal.</span>
<span class="sd">    optional_params : :class:`empix.OptionalCroppingParams` | `None`, optional</span>
<span class="sd">        The set of optional parameters. See the documentation for the class</span>
<span class="sd">        :class:`empix.OptionalCroppingParams` for details. If</span>
<span class="sd">        ``optional_params`` is set to ``None``, rather than an instance of</span>
<span class="sd">        :class:`empix.OptionalCroppingParams`, then the default values of the</span>
<span class="sd">        optional parameters are chosen.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output_signal : :class:`hyperspy._signals.signal2d.Signal2D` | :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D`</span>
<span class="sd">        The output ``hyperspy`` signal that results from the applied</span>
<span class="sd">        transformations, described above. Note that except for the title, the</span>
<span class="sd">        metadata of the output signal is determined from the metadata of the</span>
<span class="sd">        input signal.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_2D_input_signal</span><span class="p">(</span><span class="n">input_signal</span><span class="p">)</span>
    <span class="n">center</span><span class="p">,</span> <span class="n">window_dims</span><span class="p">,</span> <span class="n">pad_mode</span><span class="p">,</span> <span class="n">apply_symmetric_mask</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> \
        <span class="n">_check_and_convert_optional_params_v3</span><span class="p">(</span><span class="n">optional_params</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">_default_title</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="s2">&quot;Cropped &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="n">temp_cropping_params</span> <span class="o">=</span> <span class="n">_temp_cropping_params</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span>
                                                 <span class="n">center</span><span class="p">,</span>
                                                 <span class="n">window_dims</span><span class="p">,</span>
                                                 <span class="n">pad_mode</span><span class="p">,</span>
                                                 <span class="n">apply_symmetric_mask</span><span class="p">)</span>

    <span class="n">navigation_dims</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">navigation_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">navigation_dims</span><span class="p">)</span>
    <span class="n">input_datasubset</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">navigation_indices</span><span class="p">]</span>
    <span class="n">output_datasubset</span> <span class="o">=</span> <span class="n">_crop_datasubset</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">,</span> <span class="n">temp_cropping_params</span><span class="p">)</span>
    <span class="n">output_data_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">navigation_dims</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">output_datasubset</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">output_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">output_data_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">output_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_crop_err_msg_1</span><span class="p">)</span>

    <span class="n">output_data</span><span class="p">[</span><span class="n">navigation_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_datasubset</span>
    <span class="n">num_patterns</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">navigation_dims</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">pattern_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_patterns</span><span class="p">):</span>
        <span class="n">navigation_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">pattern_idx</span><span class="p">,</span> <span class="n">navigation_dims</span><span class="p">)</span>
        <span class="n">input_datasubset</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">navigation_indices</span><span class="p">]</span>
            
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;input_datasubset&quot;</span><span class="p">:</span> <span class="n">input_datasubset</span><span class="p">,</span>
                  <span class="s2">&quot;temp_cropping_params&quot;</span><span class="p">:</span> <span class="n">temp_cropping_params</span><span class="p">}</span>
        <span class="n">output_datasubset</span> <span class="o">=</span> <span class="n">_crop_datasubset</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">output_data</span><span class="p">[</span><span class="n">navigation_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_datasubset</span>
        
    <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;General&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">title</span><span class="p">},</span> <span class="s2">&quot;Signal&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">()}</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">output_data</span><span class="p">):</span>
        <span class="n">output_signal</span> <span class="o">=</span> <span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">output_data</span><span class="p">,</span>
                                                  <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output_signal</span> <span class="o">=</span> <span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">ComplexSignal2D</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">output_data</span><span class="p">,</span>
                                                         <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>

    <span class="n">output_axes_offsets</span> <span class="o">=</span> <span class="n">temp_cropping_params</span><span class="p">[</span><span class="s2">&quot;output_axes_offsets&quot;</span><span class="p">]</span>
    <span class="n">_update_output_signal_axes_v2</span><span class="p">(</span><span class="n">output_signal</span><span class="p">,</span>
                                  <span class="n">input_signal</span><span class="p">,</span>
                                  <span class="n">output_axes_offsets</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output_signal</span></div>



<span class="k">def</span> <span class="nf">_check_and_convert_optional_params_v3</span><span class="p">(</span><span class="n">optional_params</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">optional_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">optional_params</span> <span class="o">=</span> <span class="n">OptionalCroppingParams</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optional_params</span><span class="p">,</span> <span class="n">OptionalCroppingParams</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_check_and_convert_optional_params_v3_err_msg_1</span><span class="p">)</span>

    <span class="n">center</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">_check_and_convert_center_v3</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">)</span>

    <span class="n">window_dims</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;window_dims&quot;</span><span class="p">]</span>
    <span class="n">window_dims</span> <span class="o">=</span> <span class="n">_check_and_convert_window_dims_v2</span><span class="p">(</span><span class="n">window_dims</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">)</span>

    <span class="n">pad_mode</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;pad_mode&quot;</span><span class="p">]</span>

    <span class="n">apply_symmetric_mask</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;apply_symmetric_mask&quot;</span><span class="p">]</span>

    <span class="n">title</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">center</span><span class="p">,</span> <span class="n">window_dims</span><span class="p">,</span> <span class="n">pad_mode</span><span class="p">,</span> <span class="n">apply_symmetric_mask</span><span class="p">,</span> <span class="n">title</span>



<span class="k">def</span> <span class="nf">_check_and_convert_center_v3</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">signal</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_v</span><span class="p">,</span> <span class="n">n_h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    
        <span class="n">h_scale</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span>
        <span class="n">v_scale</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span>

        <span class="n">h_offset</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span>
        <span class="n">v_offset</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span>

        <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">h_offset</span> <span class="o">+</span> <span class="n">h_scale</span><span class="o">*</span><span class="p">((</span><span class="n">n_h</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">),</span>
                  <span class="n">v_offset</span> <span class="o">+</span> <span class="n">v_scale</span><span class="o">*</span><span class="p">((</span><span class="n">n_v</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">center</span>



<span class="k">def</span> <span class="nf">_check_and_convert_window_dims_v2</span><span class="p">(</span><span class="n">window_dims</span><span class="p">,</span> <span class="n">signal</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">window_dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_v</span><span class="p">,</span> <span class="n">n_h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">window_dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_h</span><span class="p">,</span> <span class="n">n_v</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">window_dims</span>



<span class="k">def</span> <span class="nf">_temp_cropping_params</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span>
                          <span class="n">center</span><span class="p">,</span>
                          <span class="n">window_dims</span><span class="p">,</span>
                          <span class="n">pad_mode</span><span class="p">,</span>
                          <span class="n">apply_symmetric_mask</span><span class="p">):</span>
    <span class="n">navigation_dims</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">navigation_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">navigation_dims</span><span class="p">)</span>
    <span class="n">input_datasubset</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">navigation_indices</span><span class="p">]</span>

    <span class="n">center_in_pixel_coords</span> <span class="o">=</span> <span class="n">_center_in_pixel_coords</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">center</span><span class="p">)</span>
    
    <span class="n">pad_width_1</span><span class="p">,</span> <span class="n">multi_dim_slice_1</span> <span class="o">=</span> \
        <span class="n">_pad_width_1_and_multi_dim_slice_1</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">,</span>
                                           <span class="n">center_in_pixel_coords</span><span class="p">,</span>
                                           <span class="n">window_dims</span><span class="p">,</span>
                                           <span class="n">pad_mode</span><span class="p">)</span>
    <span class="n">pad_width_2</span><span class="p">,</span> <span class="n">multi_dim_slice_2</span> <span class="o">=</span> \
        <span class="n">_pad_width_2_and_multi_dim_slice_2</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">,</span>
                                           <span class="n">center_in_pixel_coords</span><span class="p">,</span>
                                           <span class="n">window_dims</span><span class="p">,</span>
                                           <span class="n">pad_mode</span><span class="p">)</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;wrap&quot;</span> <span class="k">if</span> <span class="n">pad_mode</span> <span class="o">==</span> <span class="s2">&quot;wrap&quot;</span> <span class="k">else</span> <span class="s2">&quot;constant&quot;</span>
    <span class="n">symmetric_mask</span> <span class="o">=</span> <span class="n">_symmetric_mask</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">,</span>
                                     <span class="n">center_in_pixel_coords</span><span class="p">,</span>
                                     <span class="n">window_dims</span><span class="p">,</span>
                                     <span class="n">pad_mode</span><span class="p">,</span>
                                     <span class="n">apply_symmetric_mask</span><span class="p">)</span>
    <span class="n">output_axes_offsets</span> <span class="o">=</span> <span class="n">_offsets_after_cropping</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span>
                                                  <span class="n">center_in_pixel_coords</span><span class="p">,</span>
                                                  <span class="n">window_dims</span><span class="p">,</span>
                                                  <span class="n">pad_mode</span><span class="p">)</span>

    <span class="n">temp_cropping_params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;pad_width_1&quot;</span><span class="p">:</span> <span class="n">pad_width_1</span><span class="p">,</span>
                            <span class="s2">&quot;pad_width_2&quot;</span><span class="p">:</span> <span class="n">pad_width_2</span><span class="p">,</span>
                            <span class="s2">&quot;multi_dim_slice_1&quot;</span><span class="p">:</span> <span class="n">multi_dim_slice_1</span><span class="p">,</span>
                            <span class="s2">&quot;multi_dim_slice_2&quot;</span><span class="p">:</span> <span class="n">multi_dim_slice_2</span><span class="p">,</span>
                            <span class="s2">&quot;mode&quot;</span><span class="p">:</span> <span class="n">mode</span><span class="p">,</span>
                            <span class="s2">&quot;symmetric_mask&quot;</span><span class="p">:</span> <span class="n">symmetric_mask</span><span class="p">,</span>
                            <span class="s2">&quot;output_axes_offsets&quot;</span><span class="p">:</span> <span class="n">output_axes_offsets</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">temp_cropping_params</span>



<span class="k">def</span> <span class="nf">_center_in_pixel_coords</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">center</span><span class="p">):</span>
    <span class="n">h_scale</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span>
    <span class="n">v_scale</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span>

    <span class="n">h_offset</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span>
    <span class="n">v_offset</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span>

    <span class="n">center_in_pixel_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(((</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">h_offset</span><span class="p">)</span> <span class="o">/</span> <span class="n">h_scale</span><span class="p">,</span>
                                       <span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v_offset</span><span class="p">)</span> <span class="o">/</span> <span class="n">v_scale</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">center_in_pixel_coords</span>



<span class="k">def</span> <span class="nf">_pad_width_1_and_multi_dim_slice_1</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">,</span>
                                       <span class="n">center_in_pixel_coords</span><span class="p">,</span>
                                       <span class="n">window_dims</span><span class="p">,</span>
                                       <span class="n">pad_mode</span><span class="p">):</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">center_in_pixel_coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
             <span class="o">-</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">input_datasubset</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>

    <span class="n">pad_width_1</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="n">multi_dim_slice_1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span>

    <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;wrap&quot;</span> <span class="k">if</span> <span class="n">pad_mode</span> <span class="o">==</span> <span class="s2">&quot;wrap&quot;</span> <span class="k">else</span> <span class="s2">&quot;constant&quot;</span>
    
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">shift</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">+</span><span class="mf">0.5</span><span class="p">))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">input_datasubset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">window_dims</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">pad_mode</span> <span class="o">!=</span> <span class="s2">&quot;no-padding&quot;</span><span class="p">:</span>
            <span class="n">pad_width_1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="n">shift</span><span class="p">[</span><span class="n">idx</span><span class="p">]))[::</span><span class="n">s</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">pad_mode</span> <span class="o">!=</span> <span class="s2">&quot;no-padding&quot;</span> <span class="k">else</span> <span class="nb">max</span><span class="p">((</span><span class="n">L</span><span class="o">-</span><span class="n">p</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">c</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">pad_width_1</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">multi_dim_slice_1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">end</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">pad_mode</span> <span class="o">!=</span> <span class="s2">&quot;no-padding&quot;</span> <span class="k">else</span> <span class="nb">max</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">shift</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">multi_dim_slice_1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">multi_dim_slice_1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">multi_dim_slice_1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pad_width_1</span><span class="p">,</span> <span class="n">multi_dim_slice_1</span>



<span class="k">def</span> <span class="nf">_pad_width_2_and_multi_dim_slice_2</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">,</span>
                                       <span class="n">center_in_pixel_coords</span><span class="p">,</span>
                                       <span class="n">window_dims</span><span class="p">,</span>
                                       <span class="n">pad_mode</span><span class="p">):</span>
    <span class="n">pad_width_2</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="n">multi_dim_slice_2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span>

    <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">center_in_pixel_coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
             <span class="o">-</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">input_datasubset</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>

    <span class="n">dims_diff</span> <span class="o">=</span> <span class="n">window_dims</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">input_datasubset</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">input_datasubset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">window_dims</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">shift</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
             <span class="k">if</span> <span class="p">((</span><span class="n">pad_mode</span> <span class="o">==</span> <span class="s2">&quot;no-padding&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dims_diff</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
             <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
            
        <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">((</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">L</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">L</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">((</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">L</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">L</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="n">L</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">dims_diff</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dims_diff</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dims_diff</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">input_datasubset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span><span class="p">,</span>
                                  <span class="p">(</span><span class="n">window_dims</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">pad_width_2</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">pad_mode</span> <span class="o">==</span> <span class="s2">&quot;no-padding&quot;</span> <span class="k">else</span> <span class="n">temp</span>

            <span class="k">if</span> <span class="n">pad_mode</span> <span class="o">!=</span> <span class="s2">&quot;no-padding&quot;</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="kc">None</span>
                        
        <span class="n">multi_dim_slice_2</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>

    <span class="n">multi_dim_slice_2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">multi_dim_slice_2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pad_width_2</span><span class="p">,</span> <span class="n">multi_dim_slice_2</span>



<span class="k">def</span> <span class="nf">_symmetric_mask</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">,</span>
                    <span class="n">center_in_pixel_coords</span><span class="p">,</span>
                    <span class="n">window_dims</span><span class="p">,</span>
                    <span class="n">pad_mode</span><span class="p">,</span>
                    <span class="n">apply_symmetric_mask</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pad_mode</span> <span class="o">==</span> <span class="s2">&quot;zeros&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">apply_symmetric_mask</span><span class="p">:</span>
        <span class="n">symmetric_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window_dims</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">multi_dim_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span>
        
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">input_datasubset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">window_dims</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
        
            <span class="n">a</span> <span class="o">=</span> <span class="n">m</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">b</span> <span class="o">=</span> <span class="p">((</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">m</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">center_in_pixel_coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">c_L</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">c_R</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c_L</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">c_R</span><span class="p">)</span>
        
            <span class="n">start</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="p">(</span><span class="n">m</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">multi_dim_slice</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">stop</span><span class="p">))</span>
        
        <span class="n">multi_dim_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">multi_dim_slice</span><span class="p">)</span>
        <span class="n">symmetric_mask</span><span class="p">[</span><span class="n">multi_dim_slice</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">symmetric_mask</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">symmetric_mask</span>



<span class="k">def</span> <span class="nf">_offsets_after_cropping</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span>
                            <span class="n">center_in_pixel_coords</span><span class="p">,</span>
                            <span class="n">window_dims</span><span class="p">,</span>
                            <span class="n">pad_mode</span><span class="p">):</span>
    <span class="n">navigation_dims</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">navigation_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">navigation_dims</span><span class="p">)</span>
    <span class="n">num_axes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">input_datasubset</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">navigation_indices</span><span class="p">]</span>

    <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">center_in_pixel_coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
             <span class="o">-</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">input_datasubset</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>

    <span class="n">scales</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_axes</span><span class="p">)]</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_axes</span><span class="p">)]</span>
    <span class="n">adjusted_center</span> <span class="o">=</span> <span class="p">[</span><span class="n">offsets</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">center_in_pixel_coords</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">*</span><span class="n">scales</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">input_datasubset</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">window_dims</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">pad_mode</span> <span class="o">!=</span> <span class="s2">&quot;no-padding&quot;</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">p</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="o">+</span><span class="nb">min</span><span class="p">(</span><span class="n">shift</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span> <span class="n">k</span><span class="p">))</span>
        <span class="n">offsets</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjusted_center</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="o">*</span><span class="n">scales</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">offsets</span>



<span class="k">def</span> <span class="nf">_crop_datasubset</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">,</span> <span class="n">temp_cropping_params</span><span class="p">):</span>
    <span class="n">pad_width_1</span> <span class="o">=</span> <span class="n">temp_cropping_params</span><span class="p">[</span><span class="s2">&quot;pad_width_1&quot;</span><span class="p">]</span>
    <span class="n">pad_width_2</span> <span class="o">=</span> <span class="n">temp_cropping_params</span><span class="p">[</span><span class="s2">&quot;pad_width_2&quot;</span><span class="p">]</span>
    <span class="n">multi_dim_slice_1</span> <span class="o">=</span> <span class="n">temp_cropping_params</span><span class="p">[</span><span class="s2">&quot;multi_dim_slice_1&quot;</span><span class="p">]</span>
    <span class="n">multi_dim_slice_2</span> <span class="o">=</span> <span class="n">temp_cropping_params</span><span class="p">[</span><span class="s2">&quot;multi_dim_slice_2&quot;</span><span class="p">]</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">temp_cropping_params</span><span class="p">[</span><span class="s2">&quot;mode&quot;</span><span class="p">]</span>
    <span class="n">symmetric_mask</span> <span class="o">=</span> <span class="n">temp_cropping_params</span><span class="p">[</span><span class="s2">&quot;symmetric_mask&quot;</span><span class="p">]</span>

    <span class="n">shifted_datasubset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">,</span>
                                <span class="n">pad_width_1</span><span class="p">,</span>
                                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)[</span><span class="n">multi_dim_slice_1</span><span class="p">]</span>
    <span class="n">cropped_datasubset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">shifted_datasubset</span><span class="p">,</span>
                                <span class="n">pad_width_2</span><span class="p">,</span>
                                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)[</span><span class="n">multi_dim_slice_2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">symmetric_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cropped_datasubset</span> <span class="o">*=</span> <span class="p">(</span><span class="o">~</span><span class="n">symmetric_mask</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cropped_datasubset</span>



<span class="k">def</span> <span class="nf">_update_output_signal_axes_v2</span><span class="p">(</span><span class="n">output_signal</span><span class="p">,</span>
                                  <span class="n">input_signal</span><span class="p">,</span>
                                  <span class="n">output_axes_offsets</span><span class="p">):</span>
    <span class="n">num_axes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">output_axis_offset</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output_axes_offsets</span><span class="p">):</span>
        <span class="n">input_axis</span> <span class="o">=</span> \
            <span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">output_axis_size</span> <span class="o">=</span> \
            <span class="n">output_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
        <span class="n">new_output_axis</span> <span class="o">=</span> \
            <span class="n">hyperspy</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">UniformDataAxis</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">output_axis_size</span><span class="p">,</span>
                                          <span class="n">scale</span><span class="o">=</span><span class="n">input_axis</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
                                          <span class="n">offset</span><span class="o">=</span><span class="n">output_axis_offset</span><span class="p">,</span>
                                          <span class="n">units</span><span class="o">=</span><span class="n">input_axis</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
        
        <span class="n">output_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">update_from</span><span class="p">(</span><span class="n">new_output_axis</span><span class="p">)</span>
        <span class="n">output_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">input_axis</span><span class="o">.</span><span class="n">name</span>

    <span class="k">return</span> <span class="kc">None</span>



<span class="k">def</span> <span class="nf">_check_and_convert_block_dims</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">):</span>
    <span class="n">block_dims</span> <span class="o">=</span> <span class="n">ctor_params</span><span class="p">[</span><span class="s2">&quot;block_dims&quot;</span><span class="p">]</span>
    <span class="n">block_dims</span> <span class="o">=</span> <span class="n">czekitout</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_pair_of_positive_ints</span><span class="p">(</span><span class="n">block_dims</span><span class="p">,</span>
                                                           <span class="s2">&quot;block_dims&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">block_dims</span>



<span class="k">def</span> <span class="nf">_check_and_convert_padding_const</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">):</span>
    <span class="n">padding_const</span> <span class="o">=</span> <span class="n">ctor_params</span><span class="p">[</span><span class="s2">&quot;padding_const&quot;</span><span class="p">]</span>
    <span class="n">padding_const</span> <span class="o">=</span> <span class="n">czekitout</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_float</span><span class="p">(</span><span class="n">padding_const</span><span class="p">,</span> <span class="s2">&quot;padding_const&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">padding_const</span>



<span class="k">def</span> <span class="nf">_check_and_convert_downsample_mode</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">):</span>
    <span class="n">downsample_mode</span> <span class="o">=</span> <span class="n">ctor_params</span><span class="p">[</span><span class="s2">&quot;downsample_mode&quot;</span><span class="p">]</span>
    <span class="n">downsample_mode</span> <span class="o">=</span> <span class="n">czekitout</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_str_from_str_like</span><span class="p">(</span><span class="n">downsample_mode</span><span class="p">,</span>
                                                             <span class="s2">&quot;downsample_mode&quot;</span><span class="p">)</span>
    
    <span class="n">accepted_values</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="s2">&quot;amin&quot;</span><span class="p">,</span> <span class="s2">&quot;amax&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">downsample_mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">accepted_values</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_check_and_convert_downsample_mode_err_msg_1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">downsample_mode</span>



<span class="k">def</span> <span class="nf">_pre_serialize_block_dims</span><span class="p">(</span><span class="n">block_dims</span><span class="p">):</span>
    <span class="n">serializable_rep</span> <span class="o">=</span> <span class="n">block_dims</span>
    
    <span class="k">return</span> <span class="n">serializable_rep</span>



<span class="k">def</span> <span class="nf">_pre_serialize_padding_const</span><span class="p">(</span><span class="n">padding_const</span><span class="p">):</span>
    <span class="n">serializable_rep</span> <span class="o">=</span> <span class="n">padding_const</span>
    
    <span class="k">return</span> <span class="n">serializable_rep</span>



<span class="k">def</span> <span class="nf">_pre_serialize_downsample_mode</span><span class="p">(</span><span class="n">downsample_mode</span><span class="p">):</span>
    <span class="n">serializable_rep</span> <span class="o">=</span> <span class="n">downsample_mode</span>
    
    <span class="k">return</span> <span class="n">serializable_rep</span>



<span class="k">def</span> <span class="nf">_de_pre_serialize_block_dims</span><span class="p">(</span><span class="n">serializable_rep</span><span class="p">):</span>
    <span class="n">block_dims</span> <span class="o">=</span> <span class="n">serializable_rep</span>

    <span class="k">return</span> <span class="n">block_dims</span>



<span class="k">def</span> <span class="nf">_de_pre_serialize_padding_const</span><span class="p">(</span><span class="n">serializable_rep</span><span class="p">):</span>
    <span class="n">padding_const</span> <span class="o">=</span> <span class="n">serializable_rep</span>

    <span class="k">return</span> <span class="n">padding_const</span>



<span class="k">def</span> <span class="nf">_de_pre_serialize_downsample_mode</span><span class="p">(</span><span class="n">serializable_rep</span><span class="p">):</span>
    <span class="n">downsample_mode</span> <span class="o">=</span> <span class="n">serializable_rep</span>

    <span class="k">return</span> <span class="n">downsample_mode</span>



<div class="viewcode-block" id="OptionalDownsamplingParams"><a class="viewcode-back" href="../_autosummary/empix.OptionalDownsamplingParams.html#empix.OptionalDownsamplingParams">[docs]</a><span class="k">class</span> <span class="nc">OptionalDownsamplingParams</span><span class="p">(</span><span class="n">fancytypes</span><span class="o">.</span><span class="n">PreSerializableAndUpdatable</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The set of optional parameters for the function </span>
<span class="sd">    :func:`empix.downsample`.</span>

<span class="sd">    The Python function :func:`empix.downsample` copies a given input 2D</span>
<span class="sd">    ``hyperspy`` signal and downsamples the copy along the axes in signal space.</span>
<span class="sd">    The Python function effectively does the following: </span>

<span class="sd">    1. Groups the pixels of the copy of the input signal into so-called</span>
<span class="sd">    downsampling blocks along the axes in signal space, with dimensions</span>
<span class="sd">    determined by the parameter ``block_dims``, padding the copy with a constant</span>
<span class="sd">    value of ``padding_const`` in the case that either the horizontal or</span>
<span class="sd">    vertical dimensions of the signal space of the original input signal are not</span>
<span class="sd">    divisible by the corresponding dimensions of the downsampling blocks.</span>

<span class="sd">    2. For each downsampling block, the Python function calls a ``numpy``</span>
<span class="sd">    function determined by the parameter ``downsample_mode``, wherein the input</span>
<span class="sd">    is the array data of the downsampling block, and the output is the value of</span>
<span class="sd">    the corresponding pixel of the downsampled signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    block_dims : `array_like` (`int`, shape=(2,)), optional</span>
<span class="sd">        ``block_dims[0]`` and ``block_dims[1]`` specify the horizontal and</span>
<span class="sd">        vertical dimensions of the downsampling blocks in units of pixels.</span>
<span class="sd">    padding_const : `float`, optional</span>
<span class="sd">        ``padding_const`` is the padding constant to be applied in the case that</span>
<span class="sd">        either the horizontal or vertical dimensions of the signal space of the</span>
<span class="sd">        original input signal are not divisible by the corresponding dimensions</span>
<span class="sd">        of the downsampling blocks.</span>
<span class="sd">    downsample_mode : ``&quot;sum&quot;`` | ``&quot;mean&quot;`` | ``&quot;median&quot;`` | ``&quot;amin&quot;`` | ``&quot;amax&quot;``, optional</span>
<span class="sd">        ``downsample_mode == numpy_func.__name__`` where ``numpy_func`` is the </span>
<span class="sd">        ``numpy`` function to be applied to the downsampling blocks.</span>
<span class="sd">    title : `str` | `None`, optional</span>
<span class="sd">        If ``title`` is set to ``None``, then the title of the output signal</span>
<span class="sd">        ``output_signal`` is set to ``&quot;Downsampled &quot;+</span>
<span class="sd">        input_signal.metadata.General.title``, where ``input_signal`` is the</span>
<span class="sd">        input ``hyperspy`` signal.  Otherwise, if ``title`` is a `str`, then the</span>
<span class="sd">        ``output_signal.metadata.General.title`` is set to the value of</span>
<span class="sd">        ``title``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    core_attrs : `dict`, read-only</span>
<span class="sd">        A `dict` representation of the core attributes: each `dict` key is a</span>
<span class="sd">        `str` representing the name of a core attribute, and the corresponding</span>
<span class="sd">        `dict` value is the object to which said core attribute is set. The core</span>
<span class="sd">        attributes are the same as the construction parameters, except that </span>
<span class="sd">        their values might have been updated since construction.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_validation_and_conversion_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;block_dims&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_block_dims</span><span class="p">,</span>
         <span class="s2">&quot;padding_const&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_padding_const</span><span class="p">,</span>
         <span class="s2">&quot;downsample_mode&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_downsample_mode</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_title_v1</span><span class="p">}</span>

    <span class="n">_pre_serialization_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;block_dims&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_block_dims</span><span class="p">,</span>
         <span class="s2">&quot;padding_const&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_padding_const</span><span class="p">,</span>
         <span class="s2">&quot;downsample_mode&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_downsample_mode</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_title</span><span class="p">}</span>

    <span class="n">_de_pre_serialization_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;block_dims&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_block_dims</span><span class="p">,</span>
         <span class="s2">&quot;padding_const&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_padding_const</span><span class="p">,</span>
         <span class="s2">&quot;downsample_mode&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_downsample_mode</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_title</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">block_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                 <span class="n">padding_const</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">downsample_mode</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span>
                 <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">ctor_params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;block_dims&quot;</span><span class="p">:</span> <span class="n">block_dims</span><span class="p">,</span>
                       <span class="s2">&quot;padding_const&quot;</span><span class="p">:</span> <span class="n">padding_const</span><span class="p">,</span>
                       <span class="s2">&quot;downsample_mode&quot;</span><span class="p">:</span> <span class="n">downsample_mode</span><span class="p">,</span>
                       <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">title</span><span class="p">}</span>
        <span class="n">fancytypes</span><span class="o">.</span><span class="n">PreSerializableAndUpdatable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctor_params</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="downsample"><a class="viewcode-back" href="../_autosummary/empix.downsample.html#empix.downsample">[docs]</a><span class="k">def</span> <span class="nf">downsample</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">optional_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Downsample a given input 2D ``hyperspy`` signal.</span>

<span class="sd">    This current Python function copies a given input 2D</span>
<span class="sd">    ``hyperspy`` signal and downsamples the copy along the axes in signal space.</span>
<span class="sd">    The Python function effectively does the following: </span>

<span class="sd">    1. Groups the pixels of the copy of the input signal into so-called</span>
<span class="sd">    downsampling blocks along the axes in signal space, with dimensions</span>
<span class="sd">    determined by the parameter ``block_dims``, padding the copy with a constant</span>
<span class="sd">    value of ``padding_const`` in the case that either the horizontal or</span>
<span class="sd">    vertical dimensions of the signal space of the original input signal are not</span>
<span class="sd">    divisible by the corresponding dimensions of the downsampling blocks.</span>

<span class="sd">    2. For each downsampling block, the Python function calls a ``numpy``</span>
<span class="sd">    function determined by the parameter ``downsample_mode``, wherein the input</span>
<span class="sd">    is the array data of the downsampling block, and the output is the value of</span>
<span class="sd">    the corresponding pixel of the downsampled signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_signal : :class:`hyperspy._signals.signal2d.Signal2D` | :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D`</span>
<span class="sd">        The input ``hyperspy`` signal.</span>
<span class="sd">    optional_params : :class:`empix.OptionalDownsamplingParams` | `None`, optional</span>
<span class="sd">        The set of optional parameters. See the documentation for the class</span>
<span class="sd">        :class:`empix.OptionalDownsamplingParams` for details. If</span>
<span class="sd">        ``optional_params`` is set to ``None``, rather than an instance of</span>
<span class="sd">        :class:`empix.OptionalDownsamplingParams`, then the default values of</span>
<span class="sd">        the optional parameters are chosen.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output_signal : :class:`hyperspy._signals.signal2d.Signal2D` | :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D`</span>
<span class="sd">        The output ``hyperspy`` signal that results from the downsampling. Note</span>
<span class="sd">        that except for the title, the metadata of the output signal is</span>
<span class="sd">        determined from the metadata of the input signal.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_2D_input_signal</span><span class="p">(</span><span class="n">input_signal</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">optional_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">optional_params</span> <span class="o">=</span> <span class="n">OptionalDownsamplingParams</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optional_params</span><span class="p">,</span> <span class="n">OptionalDownsamplingParams</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_downsample_err_msg_1</span><span class="p">)</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">_default_title</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="s2">&quot;Downsampled &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="n">navigation_dims</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">navigation_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">navigation_dims</span><span class="p">)</span>
    <span class="n">input_datasubset</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">navigation_indices</span><span class="p">]</span>
    <span class="n">output_datasubset</span> <span class="o">=</span> <span class="n">_downsample_datasubset</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">,</span>
                                               <span class="n">optional_params</span><span class="p">)</span>
    <span class="n">output_data_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">navigation_dims</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">output_datasubset</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">output_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">output_data_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">output_data</span><span class="p">[</span><span class="n">navigation_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_datasubset</span>
    <span class="n">num_patterns</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">navigation_dims</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">pattern_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_patterns</span><span class="p">):</span>
        <span class="n">navigation_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">pattern_idx</span><span class="p">,</span> <span class="n">navigation_dims</span><span class="p">)</span>
        <span class="n">input_datasubset</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">navigation_indices</span><span class="p">]</span>
            
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;input_datasubset&quot;</span><span class="p">:</span> <span class="n">input_datasubset</span><span class="p">,</span>
                  <span class="s2">&quot;optional_params&quot;</span><span class="p">:</span> <span class="n">optional_params</span><span class="p">}</span>
        <span class="n">output_datasubset</span> <span class="o">=</span> <span class="n">_downsample_datasubset</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">output_data</span><span class="p">[</span><span class="n">navigation_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_datasubset</span>
        
    <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;General&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">title</span><span class="p">},</span> <span class="s2">&quot;Signal&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">()}</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">output_data</span><span class="p">):</span>
        <span class="n">output_signal</span> <span class="o">=</span> <span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">output_data</span><span class="p">,</span>
                                                  <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output_signal</span> <span class="o">=</span> <span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">ComplexSignal2D</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">output_data</span><span class="p">,</span>
                                                         <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>

    <span class="n">_update_output_signal_axes_v3</span><span class="p">(</span><span class="n">output_signal</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">,</span> <span class="n">optional_params</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output_signal</span></div>



<span class="k">def</span> <span class="nf">_downsample_datasubset</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">,</span> <span class="n">optional_params</span><span class="p">):</span>
    <span class="n">downsample_mode</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;downsample_mode&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">downsample_mode</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span>
    <span class="k">elif</span> <span class="n">downsample_mode</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span>
    <span class="k">elif</span> <span class="n">downsample_mode</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span>
    <span class="k">elif</span> <span class="n">downsample_mode</span> <span class="o">==</span> <span class="s2">&quot;amin&quot;</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span>
    
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;block_size&quot;</span><span class="p">:</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;block_dims&quot;</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
              <span class="s2">&quot;cval&quot;</span><span class="p">:</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;padding_const&quot;</span><span class="p">],</span>
              <span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="n">func</span><span class="p">}</span>

    <span class="n">downsampled_datasubset</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">block_reduce</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">,</span>
                                                          <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">downsampled_datasubset</span>



<span class="k">def</span> <span class="nf">_update_output_signal_axes_v3</span><span class="p">(</span><span class="n">output_signal</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">,</span> <span class="n">optional_params</span><span class="p">):</span>
    <span class="n">num_axes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">output_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_axes</span><span class="p">)]</span>
    <span class="n">scales</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_axes</span><span class="p">)]</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_axes</span><span class="p">)]</span>
    <span class="n">units</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">units</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_axes</span><span class="p">)]</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_axes</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;block_dims&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">offsets</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">scales</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">scales</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*=</span> <span class="n">L</span>
        
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_axes</span><span class="p">):</span>
        <span class="n">new_output_axis</span> <span class="o">=</span> <span class="n">hyperspy</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">UniformDataAxis</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">sizes</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                                        <span class="n">scale</span><span class="o">=</span><span class="n">scales</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                                        <span class="n">offset</span><span class="o">=</span><span class="n">offsets</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                                        <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">output_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">update_from</span><span class="p">(</span><span class="n">new_output_axis</span><span class="p">)</span>
        <span class="n">output_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">return</span> <span class="kc">None</span>



<span class="k">def</span> <span class="nf">_check_and_convert_new_signal_space_sizes_v1</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">):</span>
    <span class="n">new_signal_space_sizes</span> <span class="o">=</span> <span class="n">ctor_params</span><span class="p">[</span><span class="s2">&quot;new_signal_space_sizes&quot;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">new_signal_space_sizes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;obj&quot;</span><span class="p">:</span> <span class="n">new_signal_space_sizes</span><span class="p">,</span>
                      <span class="s2">&quot;obj_name&quot;</span><span class="p">:</span> <span class="s2">&quot;new_signal_space_sizes&quot;</span><span class="p">}</span>
            <span class="n">new_signal_space_sizes</span> <span class="o">=</span> \
                <span class="n">czekitout</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_pair_of_positive_ints</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="n">_check_and_convert_new_signal_space_sizes_v1_err_msg_1</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_signal_space_sizes</span>



<span class="k">def</span> <span class="nf">_check_and_convert_new_signal_space_scales_v1</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">):</span>
    <span class="n">new_signal_space_scales</span> <span class="o">=</span> <span class="n">ctor_params</span><span class="p">[</span><span class="s2">&quot;new_signal_space_scales&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">new_signal_space_scales</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="n">_check_and_convert_new_signal_space_scales_v1_err_msg_1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;obj&quot;</span><span class="p">:</span> <span class="n">new_signal_space_scales</span><span class="p">,</span>
                      <span class="s2">&quot;obj_name&quot;</span><span class="p">:</span> <span class="s2">&quot;new_signal_space_scales&quot;</span><span class="p">}</span>
            <span class="n">new_signal_space_scales</span> <span class="o">=</span> \
                <span class="n">czekitout</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_pair_of_floats</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">new_signal_space_scales</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_signal_space_scales</span>



<span class="k">def</span> <span class="nf">_check_and_convert_new_signal_space_offsets_v1</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">):</span>
    <span class="n">new_signal_space_offsets</span> <span class="o">=</span> <span class="n">ctor_params</span><span class="p">[</span><span class="s2">&quot;new_signal_space_offsets&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">new_signal_space_offsets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;obj&quot;</span><span class="p">:</span> <span class="n">new_signal_space_offsets</span><span class="p">,</span>
                      <span class="s2">&quot;obj_name&quot;</span><span class="p">:</span> <span class="s2">&quot;new_signal_space_offsets&quot;</span><span class="p">}</span>
            <span class="n">new_signal_space_offsets</span> <span class="o">=</span> \
                <span class="n">czekitout</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_pair_of_floats</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="n">_check_and_convert_new_signal_space_offsets_v1_err_msg_1</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_signal_space_offsets</span>



<span class="k">def</span> <span class="nf">_check_and_convert_spline_degrees</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">):</span>
    <span class="n">spline_degrees</span> <span class="o">=</span> <span class="n">ctor_params</span><span class="p">[</span><span class="s2">&quot;spline_degrees&quot;</span><span class="p">]</span>
    <span class="n">spline_degrees</span> <span class="o">=</span> \
        <span class="n">czekitout</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_pair_of_positive_ints</span><span class="p">(</span><span class="n">spline_degrees</span><span class="p">,</span>
                                                   <span class="s2">&quot;spline_degrees&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">spline_degrees</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">spline_degrees</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_check_and_convert_spline_degrees_err_msg_1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spline_degrees</span>



<span class="k">def</span> <span class="nf">_check_and_convert_interpolate_polar_cmpnts</span><span class="p">(</span><span class="n">ctor_params</span><span class="p">):</span>
    <span class="n">interpolate_polar_cmpnts</span> <span class="o">=</span> <span class="n">ctor_params</span><span class="p">[</span><span class="s2">&quot;interpolate_polar_cmpnts&quot;</span><span class="p">]</span>
    <span class="n">interpolate_polar_cmpnts</span> <span class="o">=</span> \
        <span class="n">czekitout</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">to_bool</span><span class="p">(</span><span class="n">interpolate_polar_cmpnts</span><span class="p">,</span>
                                  <span class="s2">&quot;interpolate_polar_cmpnts&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">interpolate_polar_cmpnts</span>



<span class="k">def</span> <span class="nf">_pre_serialize_new_signal_space_sizes</span><span class="p">(</span><span class="n">new_signal_space_sizes</span><span class="p">):</span>
    <span class="n">serializable_rep</span> <span class="o">=</span> <span class="n">new_signal_space_sizes</span>
    
    <span class="k">return</span> <span class="n">serializable_rep</span>



<span class="k">def</span> <span class="nf">_pre_serialize_new_signal_space_scales</span><span class="p">(</span><span class="n">new_signal_space_scales</span><span class="p">):</span>
    <span class="n">serializable_rep</span> <span class="o">=</span> <span class="n">new_signal_space_scales</span>
    
    <span class="k">return</span> <span class="n">serializable_rep</span>



<span class="k">def</span> <span class="nf">_pre_serialize_new_signal_space_offsets</span><span class="p">(</span><span class="n">new_signal_space_offsets</span><span class="p">):</span>
    <span class="n">serializable_rep</span> <span class="o">=</span> <span class="n">new_signal_space_offsets</span>
    
    <span class="k">return</span> <span class="n">serializable_rep</span>



<span class="k">def</span> <span class="nf">_pre_serialize_spline_degrees</span><span class="p">(</span><span class="n">spline_degrees</span><span class="p">):</span>
    <span class="n">serializable_rep</span> <span class="o">=</span> <span class="n">spline_degrees</span>
    
    <span class="k">return</span> <span class="n">serializable_rep</span>



<span class="k">def</span> <span class="nf">_pre_serialize_interpolate_polar_cmpnts</span><span class="p">(</span><span class="n">interpolate_polar_cmpnts</span><span class="p">):</span>
    <span class="n">serializable_rep</span> <span class="o">=</span> <span class="n">interpolate_polar_cmpnts</span>
    
    <span class="k">return</span> <span class="n">serializable_rep</span>



<span class="k">def</span> <span class="nf">_de_pre_serialize_new_signal_space_sizes</span><span class="p">(</span><span class="n">serializable_rep</span><span class="p">):</span>
    <span class="n">new_signal_space_sizes</span> <span class="o">=</span> <span class="n">serializable_rep</span>

    <span class="k">return</span> <span class="n">new_signal_space_sizes</span>



<span class="k">def</span> <span class="nf">_de_pre_serialize_new_signal_space_scales</span><span class="p">(</span><span class="n">serializable_rep</span><span class="p">):</span>
    <span class="n">new_signal_space_scales</span> <span class="o">=</span> <span class="n">serializable_rep</span>

    <span class="k">return</span> <span class="n">new_signal_space_scales</span>



<span class="k">def</span> <span class="nf">_de_pre_serialize_new_signal_space_offsets</span><span class="p">(</span><span class="n">serializable_rep</span><span class="p">):</span>
    <span class="n">new_signal_space_offsets</span> <span class="o">=</span> <span class="n">serializable_rep</span>

    <span class="k">return</span> <span class="n">new_signal_space_offsets</span>



<span class="k">def</span> <span class="nf">_de_pre_serialize_spline_degrees</span><span class="p">(</span><span class="n">serializable_rep</span><span class="p">):</span>
    <span class="n">spline_degrees</span> <span class="o">=</span> <span class="n">serializable_rep</span>

    <span class="k">return</span> <span class="n">spline_degrees</span>



<span class="k">def</span> <span class="nf">_de_pre_serialize_interpolate_polar_cmpnts</span><span class="p">(</span><span class="n">serializable_rep</span><span class="p">):</span>
    <span class="n">interpolate_polar_cmpnts</span> <span class="o">=</span> <span class="n">serializable_rep</span>

    <span class="k">return</span> <span class="n">interpolate_polar_cmpnts</span>



<div class="viewcode-block" id="OptionalResamplingParams"><a class="viewcode-back" href="../_autosummary/empix.OptionalResamplingParams.html#empix.OptionalResamplingParams">[docs]</a><span class="k">class</span> <span class="nc">OptionalResamplingParams</span><span class="p">(</span><span class="n">fancytypes</span><span class="o">.</span><span class="n">PreSerializableAndUpdatable</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The set of optional parameters for the function :func:`empix.resample`.</span>

<span class="sd">    The Python function :func:`empix.resample` copies a given input 2D</span>
<span class="sd">    ``hyperspy`` signal and resamples the copy along the axes in signal space by</span>
<span class="sd">    interpolating the original input signal using bivariate spines. Effectively,</span>
<span class="sd">    :func:`empix.resample` resamples the input signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    new_signal_space_sizes : array_like` (`int`, shape=(2,)) | `None`, optional</span>
<span class="sd">        If ``new_signal_space_sizes`` is set to ``None``, then</span>
<span class="sd">        ``output_signal.data.shape`` will be equal to</span>
<span class="sd">        ``input_signal.data.shape``, where ``input_signal`` is the input signal,</span>
<span class="sd">        and ``output_signal`` is the output signal to result from the</span>
<span class="sd">        resampling. Otherwise, if ``new_signal_space_sizes`` is set to a pair of</span>
<span class="sd">        positive integers, then ``output_signal.data.shape[-2]`` and</span>
<span class="sd">        ``output_signal.data.shape[-1]`` will be equal to</span>
<span class="sd">        ``new_signal_space_sizes[0]`` and ``new_signal_space_sizes[1]``</span>
<span class="sd">        respectively.</span>
<span class="sd">    new_signal_space_scales : `array_like` (`float`, shape=(2,)) | `None`, optional</span>
<span class="sd">        Continuing from above, if ``new_signal_space_scales`` is set to</span>
<span class="sd">        ``None``, then ``output_signal.axes_manager[-2].scale`` and</span>
<span class="sd">        ``output_signal.axes_manager[-1].scale`` will be equal to</span>
<span class="sd">        ``input_signal.axes_manager[-2].scale`` and</span>
<span class="sd">        ``input_signal.axes_manager[-1].scale`` respectively. If</span>
<span class="sd">        ``new_signal_space_scales`` is set to a pair of non-zero floating-point</span>
<span class="sd">        numbers, then ``output_signal.axes_manager[-2].scale`` and</span>
<span class="sd">        ``output_signal.axes_manager[-1].scale`` will be equal to</span>
<span class="sd">        ``new_signal_space_scales[0]`` and ``new_signal_space_scales[1]``</span>
<span class="sd">        respectively. Otherwise, an error is raised.</span>
<span class="sd">    new_signal_space_offsets : `array_like` (`float`, shape=(2,)) | `None`, optional</span>
<span class="sd">        Continuing from above, if ``new_signal_space_offsets`` is set to</span>
<span class="sd">        ``None``, then ``output_signal.axes_manager[-2].offset`` and</span>
<span class="sd">        ``output_signal.axes_manager[-1].offset`` will be equal to</span>
<span class="sd">        ``input_signal.axes_manager[-2].offset`` and</span>
<span class="sd">        ``input_signal.axes_manager[-1].offset`` respectively. Otherwise, if</span>
<span class="sd">        ``new_signal_space_offsets`` is set to a pair of floating-point numbers,</span>
<span class="sd">        then ``output_signal.axes_manager[-2].offset`` and</span>
<span class="sd">        ``output_signal.axes_manager[-1].offset`` will be equal to</span>
<span class="sd">        ``new_signal_space_offsets[0]`` and ``new_signal_space_offsets[1]``</span>
<span class="sd">        respectively.</span>
<span class="sd">    spline_degrees : `array_like` (`int`, shape=(2,)), optional</span>
<span class="sd">        ``spline_degrees[0]`` and ``spline_degrees[1]`` are the horizontal and</span>
<span class="sd">        vertical degrees of the bivariate splines used to interpolate the input</span>
<span class="sd">        signal. Note that ``spline_degrees`` is expected to satisfy both</span>
<span class="sd">        ``1&lt;=spline_degrees[0]&lt;=5`` and ``1&lt;=spline_degrees[1]&lt;=5``.</span>
<span class="sd">    interpolate_polar_cmpnts : `bool`, optional</span>
<span class="sd">        If ``interpolate_polar_cmpnts`` is set to ``True``, then the polar</span>
<span class="sd">        components of the input signal are separately interpolated. Otherwise,</span>
<span class="sd">        if ``interpolate_polar_cmpnts`` is set to ``False``, then the real and</span>
<span class="sd">        imaginary components of the input signal are separately interpolated.</span>
<span class="sd">        Note that if the input signal is real-valued, then this parameter is</span>
<span class="sd">        effectively ignored.</span>
<span class="sd">    title : `str` | `None`, optional</span>
<span class="sd">        If ``title`` is set to ``None``, then the title of the output signal</span>
<span class="sd">        ``output_signal`` is set to ``&quot;Resampled &quot;+</span>
<span class="sd">        input_signal.metadata.General.title``, where ``input_signal`` is the</span>
<span class="sd">        input ``hyperspy`` signal.  Otherwise, if ``title`` is a `str`, then the</span>
<span class="sd">        ``output_signal.metadata.General.title`` is set to the value of</span>
<span class="sd">        ``title``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    core_attrs : `dict`, read-only</span>
<span class="sd">        A `dict` representation of the core attributes: each `dict` key is a</span>
<span class="sd">        `str` representing the name of a core attribute, and the corresponding</span>
<span class="sd">        `dict` value is the object to which said core attribute is set. The core</span>
<span class="sd">        attributes are the same as the construction parameters, except that </span>
<span class="sd">        their values might have been updated since construction.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_validation_and_conversion_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;new_signal_space_sizes&quot;</span><span class="p">:</span> \
         <span class="n">_check_and_convert_new_signal_space_sizes_v1</span><span class="p">,</span>
         <span class="s2">&quot;new_signal_space_scales&quot;</span><span class="p">:</span> \
         <span class="n">_check_and_convert_new_signal_space_scales_v1</span><span class="p">,</span>
         <span class="s2">&quot;new_signal_space_offsets&quot;</span><span class="p">:</span> \
         <span class="n">_check_and_convert_new_signal_space_offsets_v1</span><span class="p">,</span>
         <span class="s2">&quot;spline_degrees&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_spline_degrees</span><span class="p">,</span>
         <span class="s2">&quot;interpolate_polar_cmpnts&quot;</span><span class="p">:</span> \
         <span class="n">_check_and_convert_interpolate_polar_cmpnts</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_check_and_convert_title_v1</span><span class="p">}</span>

    <span class="n">_pre_serialization_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;new_signal_space_sizes&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_new_signal_space_sizes</span><span class="p">,</span>
         <span class="s2">&quot;new_signal_space_scales&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_new_signal_space_scales</span><span class="p">,</span>
         <span class="s2">&quot;new_signal_space_offsets&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_new_signal_space_offsets</span><span class="p">,</span>
         <span class="s2">&quot;spline_degrees&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_spline_degrees</span><span class="p">,</span>
         <span class="s2">&quot;interpolate_polar_cmpnts&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_interpolate_polar_cmpnts</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_pre_serialize_title</span><span class="p">}</span>

    <span class="n">_de_pre_serialization_funcs</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;new_signal_space_sizes&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_new_signal_space_sizes</span><span class="p">,</span>
         <span class="s2">&quot;new_signal_space_scales&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_new_signal_space_scales</span><span class="p">,</span>
         <span class="s2">&quot;new_signal_space_offsets&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_new_signal_space_offsets</span><span class="p">,</span>
         <span class="s2">&quot;spline_degrees&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_spline_degrees</span><span class="p">,</span>
         <span class="s2">&quot;interpolate_polar_cmpnts&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_interpolate_polar_cmpnts</span><span class="p">,</span>
         <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">_de_pre_serialize_title</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">new_signal_space_sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">new_signal_space_scales</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">new_signal_space_offsets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">spline_degrees</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                 <span class="n">interpolate_polar_cmpnts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">ctor_params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;new_signal_space_sizes&quot;</span><span class="p">:</span> <span class="n">new_signal_space_sizes</span><span class="p">,</span>
                       <span class="s2">&quot;new_signal_space_scales&quot;</span><span class="p">:</span> <span class="n">new_signal_space_scales</span><span class="p">,</span>
                       <span class="s2">&quot;new_signal_space_offsets&quot;</span><span class="p">:</span> <span class="n">new_signal_space_offsets</span><span class="p">,</span>
                       <span class="s2">&quot;spline_degrees&quot;</span><span class="p">:</span> <span class="n">spline_degrees</span><span class="p">,</span>
                       <span class="s2">&quot;interpolate_polar_cmpnts&quot;</span><span class="p">:</span> <span class="n">interpolate_polar_cmpnts</span><span class="p">,</span>
                       <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">title</span><span class="p">}</span>
        <span class="n">fancytypes</span><span class="o">.</span><span class="n">PreSerializableAndUpdatable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctor_params</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="resample"><a class="viewcode-back" href="../_autosummary/empix.resample.html#empix.resample">[docs]</a><span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">optional_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Resample a given input 2D ``hyperspy`` signal via interpolation.</span>

<span class="sd">    This current Python function copies a given input 2D ``hyperspy`` signal and</span>
<span class="sd">    resamples the copy along the axes in signal space by interpolating the</span>
<span class="sd">    original input signal using bivariate spines. Effectively,</span>
<span class="sd">    :func:`empix.resample` resamples the input signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_signal : :class:`hyperspy._signals.signal2d.Signal2D` | :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D`</span>
<span class="sd">        The input ``hyperspy`` signal.</span>
<span class="sd">    optional_params : :class:`empix.OptionalResamplingParams` | `None`, optional</span>
<span class="sd">        The set of optional parameters. See the documentation for the class</span>
<span class="sd">        :class:`empix.OptionalResamplingParams` for details. If</span>
<span class="sd">        ``optional_params`` is set to ``None``, rather than an instance of</span>
<span class="sd">        :class:`empix.OptionalResamplingParams`, then the default values of the</span>
<span class="sd">        optional parameters are chosen.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output_signal : :class:`hyperspy._signals.signal2d.Signal2D` | :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D`</span>
<span class="sd">        The output ``hyperspy`` signal that results from the resampling. Note</span>
<span class="sd">        that except for the title, the metadata of the output signal is</span>
<span class="sd">        determined from the metadata of the input signal.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_2D_input_signal</span><span class="p">(</span><span class="n">input_signal</span><span class="p">)</span>
    <span class="n">optional_params</span> <span class="o">=</span> <span class="n">_check_and_convert_optional_params_v4</span><span class="p">(</span><span class="n">optional_params</span><span class="p">,</span>
                                                            <span class="n">input_signal</span><span class="p">)</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">_default_title</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="s2">&quot;Resampled &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="n">temp_resampling_params</span> <span class="o">=</span> <span class="n">_temp_resampling_params</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span>
                                                     <span class="n">optional_params</span><span class="p">)</span>

    <span class="n">navigation_dims</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">navigation_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">navigation_dims</span><span class="p">)</span>
    <span class="n">input_datasubset</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">navigation_indices</span><span class="p">]</span>
    <span class="n">output_datasubset</span> <span class="o">=</span> <span class="n">_resample_datasubset</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">,</span>
                                             <span class="n">temp_resampling_params</span><span class="p">)</span>
    <span class="n">output_data_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">navigation_dims</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">output_datasubset</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">output_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">output_data_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">output_data</span><span class="p">[</span><span class="n">navigation_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_datasubset</span>
    <span class="n">num_patterns</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">navigation_dims</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">pattern_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_patterns</span><span class="p">):</span>
        <span class="n">navigation_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">pattern_idx</span><span class="p">,</span> <span class="n">navigation_dims</span><span class="p">)</span>
        <span class="n">input_datasubset</span> <span class="o">=</span> <span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">navigation_indices</span><span class="p">]</span>
            
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;input_datasubset&quot;</span><span class="p">:</span> <span class="n">input_datasubset</span><span class="p">,</span>
                  <span class="s2">&quot;temp_resampling_params&quot;</span><span class="p">:</span> <span class="n">temp_resampling_params</span><span class="p">}</span>
        <span class="n">output_datasubset</span> <span class="o">=</span> <span class="n">_resample_datasubset</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">output_data</span><span class="p">[</span><span class="n">navigation_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_datasubset</span>
        
    <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;General&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="n">title</span><span class="p">},</span> <span class="s2">&quot;Signal&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">()}</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">output_data</span><span class="p">):</span>
        <span class="n">output_signal</span> <span class="o">=</span> <span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">output_data</span><span class="p">,</span>
                                                  <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output_signal</span> <span class="o">=</span> <span class="n">hyperspy</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">ComplexSignal2D</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">output_data</span><span class="p">,</span>
                                                         <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>

    <span class="n">_update_output_signal_axes_v4</span><span class="p">(</span><span class="n">output_signal</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">,</span> <span class="n">optional_params</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output_signal</span></div>



<span class="k">def</span> <span class="nf">_check_and_convert_optional_params_v4</span><span class="p">(</span><span class="n">optional_params</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">optional_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">optional_params</span> <span class="o">=</span> <span class="n">OptionalResamplingParams</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optional_params</span><span class="p">,</span> <span class="n">OptionalResamplingParams</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_check_and_convert_optional_params_v4_err_msg_1</span><span class="p">)</span>

    <span class="n">new_signal_space_sizes</span> <span class="o">=</span> \
        <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;new_signal_space_sizes&quot;</span><span class="p">]</span>
    <span class="n">new_signal_space_sizes</span> <span class="o">=</span> \
        <span class="n">_check_and_convert_new_signal_space_sizes_v2</span><span class="p">(</span><span class="n">new_signal_space_sizes</span><span class="p">,</span>
                                                     <span class="n">input_signal</span><span class="p">)</span>

    <span class="n">new_signal_space_scales</span> <span class="o">=</span> \
        <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;new_signal_space_scales&quot;</span><span class="p">]</span>
    <span class="n">new_signal_space_scales</span> <span class="o">=</span> \
        <span class="n">_check_and_convert_new_signal_space_scales_v2</span><span class="p">(</span><span class="n">new_signal_space_scales</span><span class="p">,</span>
                                                      <span class="n">input_signal</span><span class="p">)</span>

    <span class="n">new_signal_space_offsets</span> <span class="o">=</span> \
        <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;new_signal_space_offsets&quot;</span><span class="p">]</span>
    <span class="n">new_signal_space_offsets</span> <span class="o">=</span> \
        <span class="n">_check_and_convert_new_signal_space_offsets_v2</span><span class="p">(</span><span class="n">new_signal_space_offsets</span><span class="p">,</span>
                                                       <span class="n">input_signal</span><span class="p">)</span>

    <span class="n">core_attr_subset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;new_signal_space_sizes&quot;</span><span class="p">:</span> <span class="n">new_signal_space_sizes</span><span class="p">,</span>
                        <span class="s2">&quot;new_signal_space_scales&quot;</span><span class="p">:</span> <span class="n">new_signal_space_scales</span><span class="p">,</span>
                        <span class="s2">&quot;new_signal_space_offsets&quot;</span><span class="p">:</span> <span class="n">new_signal_space_offsets</span><span class="p">}</span>
    <span class="n">optional_params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">core_attr_subset</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">optional_params</span>



<span class="k">def</span> <span class="nf">_check_and_convert_new_signal_space_sizes_v2</span><span class="p">(</span><span class="n">new_signal_space_sizes</span><span class="p">,</span>
                                                 <span class="n">signal</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">new_signal_space_sizes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_v</span><span class="p">,</span> <span class="n">n_h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">new_signal_space_sizes</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_h</span><span class="p">,</span> <span class="n">n_v</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_signal_space_sizes</span>



<span class="k">def</span> <span class="nf">_check_and_convert_new_signal_space_scales_v2</span><span class="p">(</span><span class="n">new_signal_space_scales</span><span class="p">,</span>
                                                  <span class="n">signal</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">new_signal_space_scales</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">new_signal_space_scales</span> <span class="o">=</span> <span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
                                   <span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_signal_space_scales</span>



<span class="k">def</span> <span class="nf">_check_and_convert_new_signal_space_offsets_v2</span><span class="p">(</span><span class="n">new_signal_space_offsets</span><span class="p">,</span>
                                                   <span class="n">signal</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">new_signal_space_offsets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">new_signal_space_offsets</span> <span class="o">=</span> <span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span>
                                    <span class="n">signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_signal_space_offsets</span>



<span class="k">def</span> <span class="nf">_temp_resampling_params</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">optional_params</span><span class="p">):</span>
    <span class="n">old_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">old_scales</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">old_offsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

    <span class="n">new_sizes</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;new_signal_space_sizes&quot;</span><span class="p">]</span>
    <span class="n">new_scales</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;new_signal_space_scales&quot;</span><span class="p">]</span>
    <span class="n">new_offsets</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;new_signal_space_offsets&quot;</span><span class="p">]</span>

    <span class="n">h_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">old_scales</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">old_offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                      <span class="o">+</span> <span class="n">old_scales</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">old_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">v_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">old_scales</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">old_offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                                      <span class="o">+</span> <span class="n">old_scales</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">old_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    
    <span class="n">h_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">old_scales</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">new_offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                      <span class="o">+</span> <span class="n">new_scales</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">new_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">v_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">old_scales</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">new_offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                                      <span class="o">+</span> <span class="n">new_scales</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">new_sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">s_h_new</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">h_new</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">h_new</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">s_v_new</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">v_new</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">v_new</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">h_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">h_new</span><span class="p">)</span>
    <span class="n">v_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">v_new</span><span class="p">)</span>

    <span class="n">spline_degrees</span> <span class="o">=</span> <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;spline_degrees&quot;</span><span class="p">]</span>
    <span class="n">interpolate_polar_cmpnts</span> <span class="o">=</span> \
        <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;interpolate_polar_cmpnts&quot;</span><span class="p">]</span>

    <span class="n">temp_resampling_params</span> <span class="o">=</span> \
        <span class="p">{</span><span class="s2">&quot;h_old&quot;</span><span class="p">:</span> <span class="n">h_old</span><span class="p">,</span>
         <span class="s2">&quot;v_old&quot;</span><span class="p">:</span> <span class="n">v_old</span><span class="p">,</span>
         <span class="s2">&quot;h_new&quot;</span><span class="p">:</span> <span class="n">h_new</span><span class="p">,</span>
         <span class="s2">&quot;v_new&quot;</span><span class="p">:</span> <span class="n">v_new</span><span class="p">,</span>
         <span class="s2">&quot;s_h_new&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">h_new</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">h_new</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
         <span class="s2">&quot;s_v_new&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">v_new</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">v_new</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
         <span class="s2">&quot;spline_degrees&quot;</span><span class="p">:</span> <span class="n">spline_degrees</span><span class="p">,</span>
         <span class="s2">&quot;interpolate_polar_cmpnts&quot;</span><span class="p">:</span> <span class="n">interpolate_polar_cmpnts</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">temp_resampling_params</span>



<span class="k">def</span> <span class="nf">_resample_datasubset</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">,</span> <span class="n">temp_resampling_params</span><span class="p">):</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">temp_resampling_params</span><span class="p">[</span><span class="s2">&quot;v_old&quot;</span><span class="p">],</span>
              <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">temp_resampling_params</span><span class="p">[</span><span class="s2">&quot;h_old&quot;</span><span class="p">],</span>
              <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
              <span class="s2">&quot;bbox&quot;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
              <span class="s2">&quot;kx&quot;</span><span class="p">:</span> <span class="n">temp_resampling_params</span><span class="p">[</span><span class="s2">&quot;spline_degrees&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
              <span class="s2">&quot;ky&quot;</span><span class="p">:</span> <span class="n">temp_resampling_params</span><span class="p">[</span><span class="s2">&quot;spline_degrees&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
              <span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>

    <span class="n">v_new</span> <span class="o">=</span> <span class="n">temp_resampling_params</span><span class="p">[</span><span class="s2">&quot;v_new&quot;</span><span class="p">]</span>
    <span class="n">h_new</span> <span class="o">=</span> <span class="n">temp_resampling_params</span><span class="p">[</span><span class="s2">&quot;h_new&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_datasubset</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">resampled_datasubset</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">v_new</span><span class="p">,</span> <span class="n">h_new</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">temp_resampling_params</span><span class="p">[</span><span class="s2">&quot;interpolate_polar_cmpnts&quot;</span><span class="p">]:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">mag</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">v_new</span><span class="p">,</span> <span class="n">h_new</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">v_new</span><span class="p">,</span> <span class="n">h_new</span><span class="p">)</span>
            <span class="n">resampled_datasubset</span> <span class="o">=</span> <span class="n">mag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">angle</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">real_part</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">v_new</span><span class="p">,</span> <span class="n">h_new</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">input_datasubset</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">imag_part</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">v_new</span><span class="p">,</span> <span class="n">h_new</span><span class="p">)</span>
            <span class="n">resampled_datasubset</span> <span class="o">=</span> <span class="n">real_part</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">imag_part</span>

    <span class="n">s_h_new</span> <span class="o">=</span> <span class="n">temp_resampling_params</span><span class="p">[</span><span class="s2">&quot;s_h_new&quot;</span><span class="p">]</span>
    <span class="n">s_v_new</span> <span class="o">=</span> <span class="n">temp_resampling_params</span><span class="p">[</span><span class="s2">&quot;s_v_new&quot;</span><span class="p">]</span>
    <span class="n">resampled_datasubset</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">resampled_datasubset</span><span class="p">[::</span><span class="n">s_v_new</span><span class="p">,</span> <span class="p">::</span><span class="n">s_h_new</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">resampled_datasubset</span>



<span class="k">def</span> <span class="nf">_update_output_signal_axes_v4</span><span class="p">(</span><span class="n">output_signal</span><span class="p">,</span> <span class="n">input_signal</span><span class="p">,</span> <span class="n">optional_params</span><span class="p">):</span>
    <span class="n">num_axes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_signal</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">output_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_axes</span><span class="p">)]</span>
    <span class="n">scales</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_axes</span><span class="p">)]</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_axes</span><span class="p">)]</span>
    <span class="n">units</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">units</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_axes</span><span class="p">)]</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_axes</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">scales</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> \
              <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;new_signal_space_scales&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">offsets</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> \
              <span class="n">optional_params</span><span class="o">.</span><span class="n">core_attrs</span><span class="p">[</span><span class="s2">&quot;new_signal_space_offsets&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
        
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_axes</span><span class="p">):</span>
        <span class="n">new_output_axis</span> <span class="o">=</span> <span class="n">hyperspy</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">UniformDataAxis</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">sizes</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                                        <span class="n">scale</span><span class="o">=</span><span class="n">scales</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                                        <span class="n">offset</span><span class="o">=</span><span class="n">offsets</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                                        <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">output_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">update_from</span><span class="p">(</span><span class="n">new_output_axis</span><span class="p">)</span>
        <span class="n">output_signal</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">return</span> <span class="kc">None</span>



<span class="c1">###########################</span>
<span class="c1">## Define error messages ##</span>
<span class="c1">###########################</span>

<span class="n">_check_and_convert_title_v1_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``title`` must be `NoneType` or a `str`.&quot;</span><span class="p">)</span>

<span class="n">_check_and_convert_center_v1_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``center`` must be `NoneType` or a pair of real numbers.&quot;</span><span class="p">)</span>
<span class="n">_check_and_convert_center_v2_err_msg_2</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``center`` must specify a point within the boundaries of the &quot;</span>
     <span class="s2">&quot;input ``hyperspy`` signal.&quot;</span><span class="p">)</span>

<span class="n">_check_and_convert_radial_range_v1_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``radial_range`` must be `NoneType` or a pair of non-negative &quot;</span>
     <span class="s2">&quot;real numbers satisfying ``0&lt;=radial_range[0]&lt;=radial_range[1]``.&quot;</span><span class="p">)</span>

<span class="n">_check_and_convert_num_bins_v1_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``num_bins`` must be `NoneType` or a positive `int`.&quot;</span><span class="p">)</span>

<span class="n">_check_and_convert_optional_params_v1_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``optional_params`` must be `NoneType` or an instance of the &quot;</span>
     <span class="s2">&quot;class `OptionalAzimuthalAveragingParams`.&quot;</span><span class="p">)</span>

<span class="n">_azimuthally_integrate_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``optional_params`` must be `NoneType` or an instance of the &quot;</span>
     <span class="s2">&quot;class `OptionalAzimuthalIntegrationParams`.&quot;</span><span class="p">)</span>

<span class="n">_annularly_average_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``optional_params`` must be `NoneType` or an instance of the &quot;</span>
     <span class="s2">&quot;class `OptionalAnnularAveragingParams`.&quot;</span><span class="p">)</span>

<span class="n">_annularly_integrate_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``optional_params`` must be `NoneType` or an instance of the &quot;</span>
     <span class="s2">&quot;class `OptionalAnnularIntegrationParams`.&quot;</span><span class="p">)</span>

<span class="n">_check_and_convert_optional_params_v2_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``optional_params`` must be `NoneType` or an instance of the &quot;</span>
     <span class="s2">&quot;class `OptionalCumulative1dIntegrationParams`.&quot;</span><span class="p">)</span>

<span class="n">_check_and_convert_window_dims_v1_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``window_dims`` must be `NoneType` or a pair of positive &quot;</span>
     <span class="s2">&quot;integers.&quot;</span><span class="p">)</span>

<span class="n">_check_and_convert_pad_mode_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``pad_mode`` must be either ``&#39;no-padding&#39;``, ``&#39;wrap&#39;``, or &quot;</span>
     <span class="s2">&quot;``&#39;zeros&#39;``.&quot;</span><span class="p">)</span>

<span class="n">_check_and_convert_optional_params_v3_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``optional_params`` must be `NoneType` or an instance of the &quot;</span>
     <span class="s2">&quot;class `OptionalCroppingParams`.&quot;</span><span class="p">)</span>

<span class="n">_crop_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``optional_params`` specifies a crop that yields an output &quot;</span>
     <span class="s2">&quot;``hyperspy`` signal with zero elements.&quot;</span><span class="p">)</span>

<span class="n">_check_and_convert_optional_block_reduce_params_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The key ``&#39;</span><span class="si">{}</span><span class="s2">&#39;`` in the dictionary ``optional_block_reduce_params`` is &quot;</span>
     <span class="s2">&quot;invalid: the only accepted keys are ``&#39;block_size&#39;``, ``&#39;func&#39;``, &quot;</span>
     <span class="s2">&quot;``&#39;cval&#39;``, and ``&#39;func_kwargs&#39;``.&quot;</span><span class="p">)</span>

<span class="n">_check_and_convert_optional_block_reduce_params_err_msg_2</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``optional_block_reduce_params`` specifies an invalid set of &quot;</span>
     <span class="s2">&quot;optional parameters for the function &quot;</span>
     <span class="s2">&quot;:func:`skimage.measure.block_reduce`: see the traceback above for &quot;</span>
     <span class="s2">&quot;further details.&quot;</span><span class="p">)</span>

<span class="n">_check_and_convert_downsample_mode_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``downsample_mode`` must be either ``&#39;sum&#39;``, ``&#39;mean&#39;``, &quot;</span>
     <span class="s2">&quot;``&#39;median&#39;``, ``&#39;amin&#39;``, or ``&#39;amax&#39;``.&quot;</span><span class="p">)</span>

<span class="n">_downsample_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``optional_params`` must be `NoneType` or an instance of the &quot;</span>
     <span class="s2">&quot;class `OptionalDownsamplingParams`.&quot;</span><span class="p">)</span>

<span class="n">_check_and_convert_new_signal_space_sizes_v1_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``new_signal_space_sizes`` must be `NoneType` or a pair of &quot;</span>
     <span class="s2">&quot;positive integers.&quot;</span><span class="p">)</span>

<span class="n">_check_and_convert_new_signal_space_scales_v1_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``new_signal_space_scales`` must be `NoneType` or a pair of &quot;</span>
     <span class="s2">&quot;non-zero real numbers.&quot;</span><span class="p">)</span>

<span class="n">_check_and_convert_new_signal_space_offsets_v1_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``new_signal_space_offsets`` must be `NoneType` or a pair of &quot;</span>
     <span class="s2">&quot;real numbers.&quot;</span><span class="p">)</span>

<span class="n">_check_and_convert_spline_degrees_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``spline_degrees`` must be a pair of positive integers where &quot;</span>
     <span class="s2">&quot;each integer is less than or equal to ``5``.&quot;</span><span class="p">)</span>

<span class="n">_check_and_convert_optional_params_v4_err_msg_1</span> <span class="o">=</span> \
    <span class="p">(</span><span class="s2">&quot;The object ``optional_params`` must be `NoneType` or an instance of the &quot;</span>
     <span class="s2">&quot;class `OptionalResamplingParams`.&quot;</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Matthew Fitzpatrick.
      <span class="lastupdated">Last updated on Aug 15, 2023.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>